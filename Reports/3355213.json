{
  "id": 3355213,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zMzU1MjEz",
  "url": "https://hackerone.com/reports/3355213",
  "title": "Use-after-free when POST body buffer is freed before transfer",
  "state": "Closed",
  "substate": "informative",
  "severity_rating": "medium",
  "readable_substate": "Informative",
  "created_at": "2025-09-23T15:08:15.926Z",
  "submitted_at": "2025-09-23T15:08:16.305Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "giant_anteater",
    "url": "/giant_anteater",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-14ffa99f59cd01423c64904352cc130ffcb6a802eadfd11777a54485749e60f2.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 35663,
    "url": "https://hackerone.com/curl",
    "handle": "curl",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "curl",
      "twitter_handle": "",
      "website": "https://curl.se",
      "about": "cURL is an Open Source project providing a library and command-line tool doing internet transfers"
    }
  },
  "has_bounty?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2025-09-26T07:04:57.065Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2025-09-25T11:32:45.112Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "## Summary:\nI locally reproduced a heap use-after-free in libcurl by setting `CURLOPT_POSTFIELDSIZE` and `CURLOPT_POSTFIELDS` to a heap buffer and then freeing that buffer before `curl_easy_perform`. AddressSanitizer (ASan) reports a heap-use-after-free read during the request send path. This demonstrates the class of bug that occurs when the POST data buffer handed to libcurl is freed prior to the transfer.\n\nAI usage: The PoC and validation were performed manually on my machine. AI assistance was used to help structure this write-up.\n\n## Affected version\nBuilt from the repository I got from github today (CMake configure reported: `curl version=[8.17.0-DEV]`) on macOS with AppleClang and ASan.\n\nFrom CMake configure (observed during my build):\n\n  - Protocols: dict file ftp ftps gopher gophers http https imap imaps ipfs ipns ldap ldaps mqtt pop3 pop3s rtsp scp sftp smb smbs smtp smtps telnet tftp ws wss\n  - Features: alt-svc AsynchDNS brotli HSTS HTTP2 HTTPS-proxy IDN IPv6 Largefile libz NTLM SSL threadsafe TLS-SRP UnixSockets zstd\n  - Enabled SSL backends: OpenSSL v3+\n\n## Steps To Reproduce:\n\nThese are the steps I ran locally to reproduce the heap use-after-free under ASan.\n\n  1. Configure and build libcurl with AddressSanitizer:\n\n     ```bash\n     cmake -S . -B build-asan \\\n       -DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n       -DBUILD_SHARED_LIBS=ON \\\n       -DCURL_USE_LIBPSL=OFF \\\n       -DCMAKE_C_FLAGS='-fsanitize=address -fno-omit-frame-pointer' \\\n       -DCMAKE_SHARED_LINKER_FLAGS='-fsanitize=address' \\\n       -DCMAKE_EXE_LINKER_FLAGS='-fsanitize=address'\n     cmake --build build-asan -j 8\n     ```\n\n  2. Start a local HTTP server to ensure the client sends a request body:\n\n     ```bash\n     python3 -m http.server 18080 --bind 127.0.0.1 &\n     ```\n\n  3. Create the following PoC program (mirrors the misuse: set `POSTFIELDSIZE`, set `POSTFIELDS` to a malloc'd buffer, then free it before perform):\n\n     ```c\n     #include <curl/curl.h>\n     #include <stdlib.h>\n     #include <string.h>\n     #include <stdio.h>\n\n     int main(void) {\n       curl_global_init(CURL_GLOBAL_DEFAULT);\n       CURL *h = curl_easy_init();\n       if(!h) return 1;\n\n       const char *url = \"http://127.0.0.1:18080/\";\n       curl_easy_setopt(h, CURLOPT_URL, url);\n       curl_easy_setopt(h, CURLOPT_VERBOSE, 1L);\n       curl_easy_setopt(h, CURLOPT_CONNECTTIMEOUT_MS, 2000L);\n       curl_easy_setopt(h, CURLOPT_TIMEOUT_MS, 3000L);\n\n       const char payload[] = \"test data\";\n       size_t n = sizeof(payload) - 1;\n\n       char *cp = (char*)malloc(n);\n       memcpy(cp, payload, n);\n\n       curl_easy_setopt(h, CURLOPT_POSTFIELDSIZE, (long)n);\n       curl_easy_setopt(h, CURLOPT_POSTFIELDS, cp);\n\n       free(cp); // use-after-free when libcurl sends the request body\n\n       CURLcode res = curl_easy_perform(h);\n       fprintf(stderr, \"perform result: %d\\n\", (int)res);\n\n       curl_easy_cleanup(h);\n       curl_global_cleanup();\n       return 0;\n     }\n     ```\n\n  4. Compile and run the PoC against the locally built ASan libcurl (run from the repo root):\n\n     ```bash\n     # compile the PoC against the freshly built ASan libcurl\n     cc -fsanitize=address -fno-omit-frame-pointer -I include \\\n        build-asan/poc_uaf.c build-asan/lib/libcurl.dylib \\\n        -o build-asan/poc_uaf_local\n\n     # run with ASan and ensure the executable finds the local libcurl\n     DYLD_LIBRARY_PATH=build-asan/lib \\\n     ASAN_OPTIONS=halt_on_error=1:detect_invalid_pointer_pairs=1:strict_string_checks=1:strict_memcmp=1 \\\n     ./build-asan/poc_uaf_local\n     ```\n\n## Supporting Material/References:\n\nBelow is the actual ASan report I observed when running the PoC:\n\n```\n*   Trying 127.0.0.1:18080...\n* Established connection to 127.0.0.1 (127.0.0.1 port 18080) from 127.0.0.1 port XXXXX \n* using HTTP/1.x\n=================================================================\n==XXXXX==ERROR: AddressSanitizer: heap-use-after-free on address 0xXXXXXXXXXXXX at pc 0xXXXXXXXXXXXX bp 0xXXXXXXXXXXXX sp 0xXXXXXXXXXXXX\nREAD of size 9 at 0xXXXXXXXXXXXX thread T0\n    #0 0xXXXXXXXX in __asan_memcpy+0xXXX (libclang_rt.asan_osx_dynamic.dylib+0xXXXXX)\n    #1 0xXXXXXXXX in cr_buf_read sendf.c:1316\n    #2 0xXXXXXXXX in Curl_client_read sendf.c:1223\n    #3 0xXXXXXXXX in add_from_client request.c:349\n    #4 0xXXXXXXXX in Curl_bufq_sipn bufq.c:574\n    #5 0xXXXXXXXX in Curl_req_send request.c:407\n    #6 0xXXXXXXXX in Curl_http http.c:2926\n    #7 0xXXXXXXXX in multi_runsingle multi.c:2508\n    #8 0xXXXXXXXX in curl_multi_perform multi.c:2771\n    #9 0xXXXXXXXX in curl_easy_perform easy.c:846\n    #10 0xXXXXXXXX in main (poc_uaf_local+0xXXXX)\n\n0xXXXXXXXXXXXX is located 0 bytes inside of 9-byte region [...] \nfreed by thread T0 here:\n    #0 0xXXXXXXXX in wrap_free (libclang_rt.asan_osx_dynamic.dylib+0xXXXXX)\n    #1 0xXXXXXXXX in main (poc_uaf_local+0xXXXX)\n\npreviously allocated by thread T0 here:\n    #0 0xXXXXXXXX in wrap_malloc (libclang_rt.asan_osx_dynamic.dylib+0xXXXXX)\n    #1 0xXXXXXXXX in main (poc_uaf_local+0xXXXX)\n\nSUMMARY: AddressSanitizer: heap-use-after-free in __asan_memcpy\n==XXXXX==ABORTING\n```\n\nThis error consistently reproduces with the steps above.\n```\n\n#### Code locations (observed)\n\n- Read path where ASan flagged the UAF (based on backtrace): `lib/sendf.c` in `cr_buf_read` where the request body buffer is memcpy'ed during send, e.g. around this function:\n\n```1300:1323:curl/lib/sendf.c\nstatic CURLcode cr_buf_read(struct Curl_easy *data,\n                            struct Curl_creader *reader,\n                            char *buf, size_t blen,\n                            size_t *pnread, bool *peos)\n{\n  struct cr_buf_ctx *ctx = reader->ctx;\n  size_t nread = ctx->blen - ctx->index;\n  ...\n  memcpy(buf, ctx->buf + ctx->index, nread);\n  ...\n  return CURLE_OK;\n}\n```\n\n  - The exact memcpy line in the current tree:\n\n```1314:1317:curl/lib/sendf.c\n    if(nread > blen)\n      nread = blen;\n    memcpy(buf, ctx->buf + ctx->index, nread);\n    *pnread = nread;\n```\n\n- For context on how user-supplied POST data may be stored: `lib/setopt.c` updates `s->postfields` and manages `STRING_COPYPOSTFIELDS` ownership on `CURLOPT_COPYPOSTFIELDS` / `CURLOPT_POSTFIELDS`.\n\n```1675:1711:curl/lib/setopt.c\ncase CURLOPT_COPYPOSTFIELDS:\n  ...\n  s->postfields = s->str[STRING_COPYPOSTFIELDS];\n  s->method = HTTPREQ_POST;\n  break;\n\ncase CURLOPT_POSTFIELDS:\n  s->postfields = ptr;\n  /* Release old copied data. */\n  Curl_safefree(s->str[STRING_COPYPOSTFIELDS]);\n  s->method = HTTPREQ_POST;\n  break;\n```\n\n- OS/400 CCSID wrapper (root cause pattern): when handling `CURLOPT_COPYPOSTFIELDS` with an explicit size and conversion, the wrapper passes the converted buffer to `CURLOPT_POSTFIELDS` and also assigns it to `STRING_COPYPOSTFIELDS`, but later frees the same buffer before returning.\n\n  - Passing the converted buffer and assigning to `STRING_COPYPOSTFIELDS`:\n\n```1251:1253:curl/packages/OS400/ccsidcurl.c\n    result = curl_easy_setopt(easy, CURLOPT_POSTFIELDS, s);\n    data->set.str[STRING_COPYPOSTFIELDS] = s;   /* Give to library. */\n    break;\n```\n\n  - Freeing the buffer at function end:\n\n```1297:1299:curl/packages/OS400/ccsidcurl.c\n  va_end(arg);\n  free(cp);\n  return result;\n```\n\n## Impact\n\n## Summary:\nBased on direct observation, freeing the application-supplied POST body buffer after setting it with `CURLOPT_POSTFIELDS` (with an explicit `CURLOPT_POSTFIELDSIZE`) causes libcurl to dereference freed memory during the transfer, leading to a process crash (heap-use-after-free read). While this demonstration is a local misuse PoC, it shows the concrete risk of memory corruption/DoS when a client inadvertently frees the POST buffer before `curl_easy_perform`.",
  "weakness": {
    "id": 50,
    "name": "Use After Free"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": null,
  "vote_count": 1,
  "voters": [
    "stackraid"
  ],
  "severity": {
    "rating": "medium",
    "author_type": "User"
  },
  "structured_scope": {
    "databaseId": 18844,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/curl/curl",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
