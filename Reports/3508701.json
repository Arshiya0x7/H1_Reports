{
  "id": 3508701,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zNTA4NzAx",
  "url": "https://hackerone.com/reports/3508701",
  "title": "Use-After-Free in curl_easy_nextheader when reusing header handle across requests",
  "state": "Closed",
  "substate": "informative",
  "readable_substate": "Informative",
  "created_at": "2026-01-13T11:39:25.370Z",
  "submitted_at": "2026-01-13T11:39:25.595Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "is_triager?": false,
  "reporter": {
    "disabled": false,
    "username": "adce626q",
    "url": "/adce626q",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/0cvr2syvuz2x401o452dtldxakkj/3cb67cc78dc0cba55b102dd9eca2ee89b206d3e960be830f070583d9070b69ef"
    },
    "is_me?": false,
    "cleared": false,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 35663,
    "url": "https://hackerone.com/curl",
    "handle": "curl",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "curl",
      "twitter_handle": "",
      "website": "https://curl.se",
      "about": "cURL is an Open Source project providing a library and command-line tool doing internet transfers"
    }
  },
  "has_bounty?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2026-01-14T09:23:05.743Z",
  "bug_reporter_agreed_on_going_public_at": "2026-01-14T09:23:05.494Z",
  "team_member_agreed_on_going_public_at": "2026-01-14T00:03:57.253Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": ").\nThe API returns struct curl_header objects that internally reference libcurl-owned linked list nodes. When a new request is performed on the same CURL* handle, libcurl frees and rebuilds the internal header list, but previously returned struct curl_header objects remain valid to the application and are still accepted as input.\n\nPassing such a stale header object back to curl_easy_nextheader() causes libcurl to dereference a freed internal pointer, leading to a heap use-after-free.\n\nThis is a memory safety vulnerability reachable through normal API usage and attacker-controlled HTTP responses.\n\nAffected Versions\n\nAll libcurl versions that include the Headers API (curl_easy_header, curl_easy_nextheader)\n\nReproduced on:\n\nKali Linux libcurl (January 2026)\n\nLikely all current supported versions\n\nFile:\nlib/headers.c\n\nTechnical Analysis\nVulnerable Design\n\ncurl_easy_nextheader() exposes struct curl_header to the application:\n\nstruct curl_header {\n  const char *name;\n  const char *value;\n  unsigned int amount;\n  unsigned int index;\n  unsigned int origin;\n  void *anchor;   /* internal Curl_llist_node */\n};\n\n\nThe anchor field stores a pointer to libcurl’s internal linked list node:\n\ncopy_header_external(..., struct Curl_llist_node *e, ...) {\n  h->anchor = e;\n}\n\n\nLater, when a new request is performed, libcurl frees the internal header list:\n\nCurl_headers_cleanup(struct Curl_easy *data) {\n  for(e = Curl_llist_head(&data->state.httphdrs); e; e = n) {\n    struct Curl_header_store *hs = Curl_node_elem(e);\n    curlx_free(hs);\n  }\n}\n\n\nHowever, previously returned struct curl_header objects remain valid in user code and can still be passed back to:\n\ncurl_easy_nextheader(CURL *easy, unsigned int type, int request,\n                     struct curl_header *prev)\n\n\nThis function blindly dereferences:\n\npick = prev->anchor;\npick = Curl_node_next(pick);\n\n\nIf the header list has been freed and rebuilt, prev->anchor now points to freed heap memory → use-after-free.\n\nThere is:\n\nNo invalidation of old struct curl_header\n\nNo generation tracking\n\nNo lifetime enforcement\n\nThe API contract does not state that header handles become invalid after a new request.\n\nProof of Concept\n#include <stdio.h>\n#include <curl/curl.h>\n\nint main(void) {\n  CURL *curl = curl_easy_init();\n  if(!curl) return 1;\n\n  struct curl_header *h = NULL;\n\n  /* First request */\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/\");\n  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n  curl_easy_perform(curl);\n\n  /* Obtain and store a header */\n  h = curl_easy_nextheader(curl, CURLH_HEADER, -1, NULL);\n  printf(\"saved header: %s: %s\\n\", h->name, h->value);\n\n  /* Second request (frees and rebuilds internal header list) */\n  curl_easy_setopt(curl, CURLOPT_URL, \"https://httpbin.org/get\");\n  curl_easy_perform(curl);\n\n  /* Reuse stale header handle */\n  printf(\"calling nextheader with stale prev...\\n\");\n  struct curl_header *h2 = curl_easy_nextheader(curl, CURLH_HEADER, -1, h);\n  if(h2)\n    printf(\"next header: %s: %s\\n\", h2->name, h2->value);\n\n  curl_easy_cleanup(curl);\n  return 0;\n}\n\nBuild and Run\ngcc -fsanitize=address -g poc.c -lcurl -o poc\n./poc\n\nASAN Output (Excerpt)\nERROR: AddressSanitizer: heap-use-after-free\nREAD of size 13\nfreed by:\n  libcurl.so Curl_headers_cleanup\nallocated by:\n  libcurl.so Curl_headers_push\n\n\nThis confirms that curl_easy_nextheader() dereferences freed memory.\n\n## Impact\n\nSecurity Impact\n\nA malicious HTTP server can influence response headers and trigger a heap use-after-free in applications using libcurl’s Headers API when multiple requests are performed on the same CURL* handle.\n\nThis can lead to:\n\nProcess crash (Denial of Service)\n\nHeap memory corruption\n\nPotential code execution depending on allocator state and surrounding memory\n\nThe vulnerability:\n\nIs reachable through documented public API\n\nIs triggered by attacker-controlled HTTP responses\n\nDoes not require MITM",
  "weakness": {
    "id": 50,
    "name": "Use After Free"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [
    {
      "id": 5220506,
      "file_name": "poc.c",
      "expiring_url": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/j2qdvgsjxrabe3fc5o1wn135epz5?response-content-disposition=attachment%3B%20filename%3D%22poc.c%22%3B%20filename%2A%3DUTF-8%27%27poc.c&response-content-type=text%2Fx-csrc&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQ7D5I6LLI%2F20260114%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20260114T100525Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEE8aCXVzLXdlc3QtMiJIMEYCIQDwIF%2BGENfPIBu859JBrxGyw4Bi0Gb47BY3Vamo54E9UQIhANLNojdlZQHJD9OowcFpB%2FO0NbiC%2B1bOYSTKJveZgILJKrIFCBgQAxoMMDEzNjE5Mjc0ODQ5IgylAf7xLtj3gjxUqNcqjwVp1bEu%2BaqEkO94Aju0jHbXq89o4vaeqvRmaWzFQPuWmnADpu3iuxQMiSgU12k1kgKwnr2jq752WliGVTLU2%2BMSz0elHdD3lBq5DXF%2Fr37r9GHubeABH5vzxJNhsVHOkh%2BK9V9kJVqsASHLspp28H8GmKHoAOtaIZMlk7tFqSokS8ycz4pdoHvdjl2qS%2B7AZUgmQVCMpOsYIyF4Ota5x0dP7tWTcswM8mP2SOBkJ7X%2FvQ2%2BbA2gUFc3yAtEtfgDCTzmLKSBzZKitsqvaxH6xQn%2Fvi2bhM8vi%2BG%2BeotCKMWZS0fez2jaFppXKmi8a1uCjyVB6u00MeKVw%2BMMY0e5KwwP%2FCG13CVvxxQ4dMpP1OcqNLix1Ftv1VB5W0nCSCDfX%2FroZusRrS9%2BIeArdVo%2BC6jwBlh65GeqfLjNKgNUvMi9wq6Bfh%2FAxE1BnVYhtXR4HeqGbqQtFDwjcV2K4SdgJIzwyfCty%2F%2BV%2B8%2FZH7cUdK%2BQol42G59wAtut5Dbty6Zq8QjZdHf%2FT7t0mAjwPBLT7EUNCwuPaiqPIgGGJ3dYneJyivqZ77yn6jCy0mdksM8ERqKIs3jQGx2VvK2XJ7l%2BTy6tLQaqW9y%2FfF6uCcDiP%2F%2FQBZp2nqRRgjDFjQ1aAPXYidgryh4wq8ICxgi4ah%2FITEKiAn9iaZKaVC1teSVM1%2FmOZeZBVwlvyHk5yVM0mrFptShbyDk92m9pv3D1tHTcyl7sZyOLU6R2OqVLFl8286rL8sezQOVphLH9vzSaXN%2FGuLgq6wx2bqaLTmZvc2kLk1x%2FGThq%2BWakin5dhfi6Hv%2FAtEn82WGD69CSBliUsR4XLDBC12kdv%2F4TL2fR938FyRhVnrcm10FiWy8zv1hjHYMaMNb1nMsGOrAB6EIXsrO7cZJQhEHBV2gj5hl8KXTVDUjLy0U3hlRQIZ3S2NGfywaLF%2FR%2BcMI4l773UomO%2BoKzqB%2FoOBqRCVfR6zPmdzOVBoJrFeHfxn5BBo%2Fe7fLXmFdzJAzo5dONMQ5rSV0Kw90ZsNB3DIhYWR6r0pWsv5Qq0a2We9h%2BwlClH7pn3F3G09VqU4waK2ANvnvupmORqlZ4LIeR86uFFzPi2IsN7HJPlqDAeXiwW40o1ns%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=2050037853c2ba6d9a88d1d9ccb95952c3d8e8b071f707f25ce2007cf40cff8d",
      "file_size": 818,
      "type": "text/x-csrc",
      "moderated": null
    }
  ],
  "allow_singular_disclosure_at": null,
  "vote_count": 1,
  "voters": [
    "adce626q"
  ],
  "structured_scope": {
    "databaseId": 18844,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/curl/curl",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
