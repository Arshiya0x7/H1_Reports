{
  "id": 423467,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC80MjM0Njc=",
  "url": "https://hackerone.com/reports/423467",
  "title": "H1514 Ability to MiTM Shopify PoS Session to Takeover Communications",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "medium",
  "readable_substate": "Resolved",
  "created_at": "2018-10-13T19:35:59.245Z",
  "submitted_at": "2018-10-13T19:35:59.245Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "teknogeek",
    "url": "/teknogeek",
    "profile_picture_urls": {
      "small": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/variants/grtxx8fvv0keqmxqe2pk3xhxym1r/3cb67cc78dc0cba55b102dd9eca2ee89b206d3e960be830f070583d9070b69ef?response-content-disposition=inline%3B%20filename%3D%22binary-square.jpg%22%3B%20filename%2A%3DUTF-8%27%27binary-square.jpg&response-content-type=image%2Fjpeg&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQWWNGZ4TV%2F20250921%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250921T135423Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEI3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQDW8aJa%2B6xRGWoYeQH5YEeE9kjznZunA6kwA0dkt8kEJgIga7q704KO5MWh39EM186YJtzUR4D2pBkMTWy00MbrgqAqsgUIFhADGgwwMTM2MTkyNzQ4NDkiDDtRYSod9fhNGv%2BJjSqPBeIhz12eaVz4fzSG%2FSymFey5UBLHmZoYqx%2BgsO5yV4col%2BqTz6%2BSYTh%2FhOxg0uayWqykPZqiPTBxdtTIiPUR93kAY7kcywbMfZ09TkoDfvRNH5GygEufaXCqYyhmdsz9Q8OV7w9BN65Iu8RmXVRSX7NWW2BVZnfT0Dz2uEBcatpV5FlcP%2BZ%2F8k0u6Wsajt%2B5TfQ9kiwnSONB4ewzgkF0Z%2BPunb2MzHw%2FJJzkJ7rkhzTw6hmY0sVa0lObLXgC3OCM4TSfM%2FHnLgeb0aPpnTqO79s9lXb36U0pr53G37V9w7LWkbPR%2BSfv4t8oaTTKUr4ns5X5OVjlvOnLa5%2BQH2C2jPO49oxErfriEv6BeYKFg2S14wnL8bg8UgvcK7C6U2F8g3lAZwIdz2izAKWT9pvOYzTq%2FmWT5bnHqhpKr6twYKK4WDjA5hLNVInArpJ8Ns3FKm6uzvBC5Y%2BfTemYm%2FqaMKEt0ulcTqkCSqElnfjAe0agwf0iL1Rf4kYRD7iHFRy2E18xbZg7MIGsxkMGW439Wkuw4D17jDGoFtSE08cRhLRIS3ZHy2ruvH8kFULfeOdFgVsXFHdZCuMO4OOJv7Gghaz2GyAXH8CtGGm35nEnG%2FAxNN%2BudtvPuk1SzSaTOS%2BcgVoplbgs5agOjetwJyyYV6Cx2amEluMu421KcWhedjenb2y0eD8c82mYC7DRI11VKAnFN3qDfjyw7Q55ivibcAEYMhRr9VjEVVC5ORFRvH20r9W7zYatoEmtMlNn%2BDQTf2MaQz%2BMtAnxyL0YT7fvOlDL607lZ7oYywR5odBm602%2BuCTfwSq9PPRBJTtjgfpK7ubiriJfgnrk1Fxb2flheJCfUkGHZ21yUTxGi11J0Fsw1%2B2%2FxgY6sQHVWJ4iney%2B7mK48DbH4cwpthuOXuyqSAXzeb0rs5EA7ULnAqkMMXDRf65fLIw3a7Lk6uhXuHS0AJcM8VBOWP%2FNs%2B9ZhUmo2ij85rLwq5ZOXLqw4hIqZWucYBiD7c%2BtHMuVJRl99kHcNndYDmlqCv2313iweC7S2aj6osaP3w4kFfCyZ0ZJjHp%2FhLf%2FF%2Btfw55r5T1srbUpmJzRkeqQK6m%2FvW%2Bc7KsL7CQXMfBkOC8s31U%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=f505174aa7cbfc33617719bf9ae524aeb7f3f25927079d65e8c084baa281f75e"
    },
    "is_me?": false,
    "cleared": true,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 1382,
    "url": "https://hackerone.com/shopify",
    "handle": "shopify",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/fjjiC5585s8WoDGHv2M5okbJ/3cb67cc78dc0cba55b102dd9eca2ee89b206d3e960be830f070583d9070b69ef",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/fjjiC5585s8WoDGHv2M5okbJ/d9695107bfcd68eeb1c9e0912b109cdae9a6c00c0bda6fd4cbd6d9bdb828840a"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "Shopify",
      "twitter_handle": "",
      "website": "https://www.shopify.com",
      "about": "Shopify is a multi-channel commerce platform that helps people sell online, in-store, and everywhere in between."
    }
  },
  "has_bounty?": true,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2019-11-04T01:07:32.970Z",
  "bug_reporter_agreed_on_going_public_at": "2019-11-04T01:07:32.893Z",
  "team_member_agreed_on_going_public_at": "2019-11-01T15:34:24.977Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "Hi @iv-rodriguez,\n\nAfter a decent amount more digging and research, I must disagree with you on the \"expecting to work offline\" portion. The code actually specifically listens on all local interfaces (`0.0.0.0`) and the wifi network address is specifically used in the QR code connection string, as shown here in `com.shopify.pos.customerview.server.CustomerViewWebSocketServer::getConnectionString()` in the `com.shopify.pos` app:\n\n```java\nprivate final String getConnectionString() {\n    String initialPublicKey = this.crypto.initialPublicKey();\n    String initialNonce = this.crypto.initialNonce();\n    String currentWifiIpAddress = NetworkUtility.getCurrentWifiIpAddress(PosApplication.Companion.getInstance());\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append(this.protocol);\n    stringBuilder.append(\"://\");\n    stringBuilder.append(currentWifiIpAddress);\n    stringBuilder.append(':');\n    stringBuilder.append(this.port);\n    stringBuilder.append(';');\n    stringBuilder.append(initialPublicKey);\n    stringBuilder.append(';');\n    stringBuilder.append(initialNonce);\n    stringBuilder.append(';');\n    PayloadManager payloadManager = this.payloadManager;\n    if (payloadManager == null) {\n        Intrinsics.throwUninitializedPropertyAccessException(\"payloadManager\");\n    }\n    stringBuilder.append(payloadManager.getSchemaVersion());\n    return stringBuilder.toString();\n}\n```\nThis can also be seen from netstat on the device:\n\n```\nvbox86p:/ # netstat -an | egrep 'LISTEN[^I]'\ntcp        0      0 0.0.0.0:24800           0.0.0.0:*               LISTEN\ntcp        0      0 127.0.0.1:24801         0.0.0.0:*               LISTEN\ntcp        0      0 127.0.0.1:27042         0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:22468           0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:24810           0.0.0.0:*               LISTEN\ntcp        0      0 127.0.0.1:24811         0.0.0.0:*               LISTEN\ntcp        0      0 0.0.0.0:6379            0.0.0.0:*               LISTEN\ntcp        0      0 127.0.0.1:5037          0.0.0.0:*               LISTEN\ntcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN\ntcp        0      0 :::5000                 :::*                    LISTEN <---\ntcp        0      0 :::24296                :::*                    LISTEN\ntcp        0      0 :::6379                 :::*                    LISTEN\ntcp        0      0 :::5555                 :::*                    LISTEN\n```\n\n\nIn addition to this, the main point of this attack is to show how a merchant can abuse this functionality to cause extra charges to the customer, unknowingly. I was able to build a relay server for the WebSocket and could snoop on the raw messages without any issue.\n\nUsing an ARP spoofing attack it would be possible to MiTM the WebSocket between the real server and the customer while on the same network. At this point, you still need to obtain the initial public key that is in the QR code. This can be done by forcing the client to accept a new one by altering the message types to contain a new receiverPublicKey.\n\nThis faulty logic can be seen here in `com.shopify.pos.customerview.common.crypto.ClientCryptoProtocol::receiveMessageFromServer()` in the `com.shopify.pos.customerview` app:\n\n```java\npublic void receiveMessageFromServer(String str, CryptoType cryptoType, String str2) {\n    Intrinsics.checkParameterIsNotNull(str, \"message\");\n    Intrinsics.checkParameterIsNotNull(cryptoType, \"type\");\n    Intrinsics.checkParameterIsNotNull(str2, \"publicKeyString\");\n    if (WhenMappings.$EnumSwitchMapping$0[cryptoType.ordinal()] != 1) {\n        str = new Hex().decode(str);\n        Intrinsics.checkExpressionValueIsNotNull(str, \"decodedMessageString\");\n        str = handleIncomingMessage(str, cryptoType, str2);\n        if (str != null) {\n            getDecryptedMessageHandler().invoke(new String(str, Charsets.UTF_8));\n            str = handleOutgoingMessage(CryptoConstant.ACK.encoded(), cryptoType);\n            if (str != null) {\n                str = new Hex().encode(str);\n                Intrinsics.checkExpressionValueIsNotNull(str, \"Hex().encode(cipherText)\");\n                String publicKey = getSenderKeyPair().getPublicKey().toString();\n                Intrinsics.checkExpressionValueIsNotNull(publicKey, \"senderKeyPair.publicKey.toString()\");\n                getEncryptedMessageHandler().invoke(new CryptoMessage(cryptoType, str, publicKey));\n                return;\n            }\n            return;\n        }\n        return;\n    }\n    str = new Hex().decode(str2);\n    Intrinsics.checkExpressionValueIsNotNull(str, \"Hex().decode(publicKeyString)\");\n--->setReceiverPublicKey(str);\n    onAckReceived();\n}\n```\n\nNormally, when the customer view initially connects to the server, the public key and nonce from the QR code are stored from the `com.shopify.pos.customerview.common.crypto.ClientCryptoProtocol::start()` method in the `com.shopify.pos.customerview` app:\n\n```java\npublic void start(String str, String str2, Function0<Unit> function0) {\n    Intrinsics.checkParameterIsNotNull(str, \"publicKeyString\");\n    Intrinsics.checkParameterIsNotNull(str2, \"randomString\");\n    Intrinsics.checkParameterIsNotNull(function0, \"startCompletion\");\n    setSenderKeyPair(getCrypto().generateKeyPair());\n    setReceiverKeyPair(getCrypto().generateKeyPair());\n    str = new Hex().decode(str);\n    str2 = new Hex().decode(str2);\n    Intrinsics.checkExpressionValueIsNotNull(str, \"publicKey\");\n--->setReceiverPublicKey(str);\n    Intrinsics.checkExpressionValueIsNotNull(str2, \"random\");\n    byte[] encrypt = encrypt(str2, getSenderKeyPair(), str);\n    str = encrypt(str2, getReceiverKeyPair(), str);\n    if (encrypt != null) {\n        if (str != null) {\n            CryptoType cryptoType = CryptoType.SENDER_INIT;\n            String encode = new Hex().encode(encrypt);\n            Intrinsics.checkExpressionValueIsNotNull(encode, \"Hex().encode(sCiphertext)\");\n            String publicKey = getSenderKeyPair().getPublicKey().toString();\n            Intrinsics.checkExpressionValueIsNotNull(publicKey, \"senderKeyPair.publicKey.toString()\");\n            getEncryptedMessageHandler().invoke(new CryptoMessage(cryptoType, encode, publicKey));\n            CryptoType cryptoType2 = CryptoType.RECEIVER_INIT;\n            str = new Hex().encode(str);\n            Intrinsics.checkExpressionValueIsNotNull(str, \"Hex().encode(rCiphertext)\");\n            String publicKey2 = getReceiverKeyPair().getPublicKey().toString();\n            Intrinsics.checkExpressionValueIsNotNull(publicKey2, \"receiverKeyPair.publicKey.toString()\");\n            getEncryptedMessageHandler().invoke(new CryptoMessage(cryptoType2, str, publicKey2));\n            function0.invoke();\n        }\n    }\n}\n```\n\nAs you can see in the code above, the same `setReceiverPublicKey(...)` method is used in the start method as well as the receiveMessageFromServer method. This is the public key that is later used to encrypt the messages with Curve25519 before being sent to and from the server. As a result, when the message type satisfies the if statement below, the rest of the logic is skipped, and the receiver public key can be overridden:\n\n```java\npublic void receiveMessageFromServer(String str, CryptoType cryptoType, String str2) {\n    Intrinsics.checkParameterIsNotNull(str, \"message\");\n    Intrinsics.checkParameterIsNotNull(cryptoType, \"type\");\n    Intrinsics.checkParameterIsNotNull(str2, \"publicKeyString\");\n--->if (WhenMappings.$EnumSwitchMapping$0[cryptoType.ordinal()] != 1) {\n        str = new Hex().decode(str);\n        Intrinsics.checkExpressionValueIsNotNull(str, \"decodedMessageString\");\n...\n    }\n    str = new Hex().decode(str2);\n    Intrinsics.checkExpressionValueIsNotNull(str, \"Hex().decode(publicKeyString)\");\n    setReceiverPublicKey(str);\n    onAckReceived();\n}\n```\n\nCombining this together...\n\n- the device listens on `0.0.0.0:5000` but instructs clients to connect to the wifi IP address\n- the communications between the customer view and pos apps happens over a normal `ws://` connection with no encryption outside the Curve25519 box\n- there is an initial communication process that occurs, allowing the attacker to know the next valid public key to sign messages with in order to continue communication with the legitimate server\n- since each portion of the communication stems off of the initial QR code public key, overriding this would grant full control to the session\n- as a result, an attacker can override the initial receiver public key to fully take-over the session during a MiTM attack\n\n\nThanks, @teknogeek\n\n\nP.S. This is a copy of my comment from #423378 which I was asked to re-submit as a new bug\n\n## Impact\n\nAn attacker can take-over a session by performing a MiTM attack on a PoS customer view session.",
  "weakness": {
    "id": 65,
    "name": "Business Logic Errors"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": null,
  "vote_count": 370,
  "voters": [
    "njmulsqb",
    "angu_",
    "misosoup",
    "sebd",
    "k0ns0l",
    "nohats",
    "orange303",
    "cxzer0",
    "hundaoln",
    "th3hidd3nmist",
    "and 360 more..."
  ],
  "severity": {
    "rating": "medium",
    "author_type": "Team"
  },
  "structured_scope": {
    "databaseId": 37199,
    "asset_type": "OTHER",
    "asset_identifier": "Shopify Mobile Applications",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "id": 15376,
      "category": "team",
      "content": "The Shopify \"point of sale\" application allows a shop owner to pair a \"customer view\" application which shows the customer application what is in the customer's cart as they go through checkout. The protocol used to communicate between the point of sale application and the customer view application had a vulnerability where no validation would be done before accepting a new public key. This allowed an somone on the network to take over the communication protocol by initiating an exchange to either participant. Therefore if someone took over the communication session they could:\n\n- Intercept what is being added to the cart and/or display incorrect information to the customer\n- Change the amount a customer has tipped\n- Opt customers into e-mails\n- View/Change customer e-mail addresses\n- View/Change customer phone numbers\n\nWe fixed this by validating that the encrypted ACK message can be decrypted before accepting a new public key. ",
      "updated_at": "2019-04-24T19:49:55.131Z",
      "can_view?": true,
      "can_create?": false,
      "attachments": [],
      "user": {
        "id": 175526,
        "username": "shopify-peteryaworski",
        "name": "Peter Yaworski",
        "bio": "",
        "cleared": false,
        "verified": false,
        "website": null,
        "location": "",
        "created_at": "2017-06-13T14:40:59.020Z",
        "url": "https://hackerone.com/shopify-peteryaworski",
        "hackerone_triager": false,
        "hackerone_employee": false,
        "user_type": "company",
        "profile_picture_urls": {
          "small": "https://profile-photos.hackerone-user-content.com/variants/000/175/526/7ba4844078e290c91c4c46a345b4f9e7666f3ed4_original.jpg/3cb67cc78dc0cba55b102dd9eca2ee89b206d3e960be830f070583d9070b69ef",
          "medium": "https://profile-photos.hackerone-user-content.com/variants/000/175/526/7ba4844078e290c91c4c46a345b4f9e7666f3ed4_original.jpg/d9695107bfcd68eeb1c9e0912b109cdae9a6c00c0bda6fd4cbd6d9bdb828840a",
          "xtralarge": "https://hackerone.com/rails/active_storage/representations/redirect/eyJfcmFpbHMiOnsiZGF0YSI6MjYwMDQsInB1ciI6ImJsb2JfaWQifX0=--9107c0a581421900ec9077ccbdf70c2c5004273f/eyJfcmFpbHMiOnsiZGF0YSI6eyJmb3JtYXQiOiJqcGciLCJyZXNpemUiOiIyNjB4MjYwXHUwMDNlIn0sInB1ciI6InZhcmlhdGlvbiJ9fQ==--cf3aeca803d1baf476958c689ca7b472a4cb54f1/profile.jpg"
        }
      }
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
