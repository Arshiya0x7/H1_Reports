{
  "id": 3373640,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zMzczNjQw",
  "url": "https://hackerone.com/reports/3373640",
  "title": "OpenSSL backend: X509 peer certificate not freed in ossl_get_channel_binding causes per-request memory leak (DoS risk for long-lived clients)",
  "state": "Closed",
  "substate": "informative",
  "severity_rating": "low",
  "readable_substate": "Informative",
  "created_at": "2025-10-06T21:39:13.962Z",
  "submitted_at": "2025-10-06T21:39:14.422Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "giant_anteater",
    "url": "/giant_anteater",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-14ffa99f59cd01423c64904352cc130ffcb6a802eadfd11777a54485749e60f2.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 35663,
    "url": "https://hackerone.com/curl",
    "handle": "curl",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "curl",
      "twitter_handle": "",
      "website": "https://curl.se",
      "about": "cURL is an Open Source project providing a library and command-line tool doing internet transfers"
    }
  },
  "has_bounty?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2025-10-08T06:38:54.740Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2025-10-07T15:55:02.756Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "## Summary:\nIn curl’s OpenSSL backend, `ossl_get_channel_binding` retains a new reference to the server’s X509 certificate via `SSL_get1_peer_certificate` and never releases it. When Negotiate (SPNEGO) over TLS is in use, this path is invoked and leaks one X509 object per trigger. Over many requests in a long‑running libcurl client, this leads to unbounded memory growth and potential denial‑of‑service.\n\nThis occurs only with the OpenSSL backend (>= 1.1.0 gate present), when curl/libcurl is built with GSSAPI (`HAVE_GSSAPI`), over HTTPS when a Negotiate challenge is processed.\n\nNotes:\n- The Negotiate challenge over HTTPS is sufficient to trigger channel binding retrieval; a functional Kerberos setup is not required for this leak to manifest.\n- Each trigger leaks one X509 reference.\n\n## Supporting Material/References:\n- Code location showing missing X509_free on all paths:\n```5650:5679:curl/lib/vtls/openssl.c\n  cert = SSL_get1_peer_certificate(octx->ssl);\n  if(!cert) {\n    /* No server certificate, don't do channel binding */\n    return CURLE_OK;\n  }\n\n  if(!OBJ_find_sigid_algs(X509_get_signature_nid(cert), &algo_nid, NULL)) {\n    failf(data,\n          \"Unable to find digest NID for certificate signature algorithm\");\n    return CURLE_SSL_INVALIDCERTSTATUS;\n  }\n\n  /* https://datatracker.ietf.org/doc/html/rfc5929#section-4.1 */\n  if(algo_nid == NID_md5 || algo_nid == NID_sha1) {\n    algo_type = EVP_sha256();\n  }\n  else {\n    algo_type = EVP_get_digestbynid(algo_nid);\n    if(!algo_type) {\n      algo_name = OBJ_nid2sn(algo_nid);\n      failf(data, \"Could not find digest algorithm %s (NID %d)\",\n            algo_name ? algo_name : \"(null)\", algo_nid);\n      return CURLE_SSL_INVALIDCERTSTATUS;\n    }\n  }\n\n  if(!X509_digest(cert, algo_type, buf, &length)) {\n    failf(data, \"X509_digest() failed\");\n    return CURLE_SSL_INVALIDCERTSTATUS;\n  }\n```\n\n```5681:5688:curl/lib/vtls/openssl.c\n  /* Append \"tls-server-end-point:\" */\n  if(curlx_dyn_addn(binding, prefix, sizeof(prefix) - 1) != CURLE_OK)\n    return CURLE_OUT_OF_MEMORY;\n  /* Append digest */\n  if(curlx_dyn_addn(binding, buf, length))\n    return CURLE_OUT_OF_MEMORY;\n\n  return CURLE_OK;\n\n\nStatement on AI usage: AI was used in parts of detection, triage, fix generation and reporting writing in combination with classical tooling and manual human input.\n\n## Impact\n\n## Impact\n\nA remote HTTPS server that advertises `WWW-Authenticate: Negotiate` can cause a libcurl client (built with OpenSSL and GSSAPI) to leak one X509 certificate reference per authentication attempt when TLS channel binding is retrieved.\n\nOver many requests in a long-lived process, this leads to unbounded memory growth and a denial-of-service condition due to resource exhaustion.\n\nThe leak occurs because `ossl_get_channel_binding` calls `SSL_get1_peer_certificate` (which increments the X509 reference count) but never calls `X509_free` on any return path—success or error.\n\n### Constraints:\n- Requires libcurl built with OpenSSL (>=1.1.0) and GSSAPI support\n- Only affects clients using Negotiate authentication over HTTPS\n- Linear leak rate (not amplified), but unbounded over time\n\nSeverity: **Low** (limited scope, requires specific build configuration and authentication method, but genuine DoS risk for affected deployments)",
  "weakness": {
    "id": 48,
    "name": "Uncontrolled Resource Consumption"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": null,
  "vote_count": 0,
  "voters": [],
  "severity": {
    "rating": "low",
    "author_type": "User"
  },
  "structured_scope": {
    "databaseId": 18844,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/curl/curl",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
