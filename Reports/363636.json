{
  "id": 363636,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zNjM2MzY=",
  "url": "https://hackerone.com/reports/363636",
  "title": "DoS through PeerExplorer",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "high",
  "readable_substate": "Resolved",
  "created_at": "2018-06-09T05:00:54.753Z",
  "submitted_at": "2018-06-09T05:00:54.753Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "z3t",
    "url": "/z3t",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/042/875/f509a2a60ca4f406a7194137e1f5df0ea52cc0c9_original.jpg/3cb67cc78dc0cba55b102dd9eca2ee89b206d3e960be830f070583d9070b69ef"
    },
    "is_me?": false,
    "cleared": true,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 25854,
    "url": "https://hackerone.com/rootstocklabs",
    "handle": "rootstocklabs",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/7q67oftq9lv3d00bgl62x7sn1j6e/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/7q67oftq9lv3d00bgl62x7sn1j6e/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "Rootstock Labs",
      "twitter_handle": "rootstocklabs",
      "website": "https://rootstocklabs.com",
      "about": "Make Bitcoin work for everyone"
    }
  },
  "has_bounty?": true,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2019-09-18T13:16:28.759Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2019-09-18T13:07:08.066Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "**Summary:** The peer discovery implementation is vulnerable to a Denial of Service attack due to improper management of connections.\n\n**Description:** The two main files of interest in detailing this vulnerability are [PeerExplorer.java](https://github.com/rsksmart/rskj/blob/master/rskj-core/src/main/java/co/rsk/net/discovery/PeerExplorer.java) and [NodeChallengeManager.java](https://github.com/rsksmart/rskj/blob/master/rskj-core/src/main/java/co/rsk/net/discovery/NodeChallengeManager.java). To explain the flow of execution I'll be mentioning two theoretical nodes: an attacker, \"N1\" and a target, \"N2\".\n\nWhen N1 sends an initial \"ping\" message to N2, N2 will reply with a \"pong\" message and a subsequent ping message to continue the handshake. After this, when N1 replies with a pong message, N2 will attempt to add N1 to its structure holding established connections. The relevant code snippets from `PeerExplorer.java` are below:\n```    \npublic void handlePong(String ip, PongPeerMessage message) {\n\tPeerDiscoveryRequest request = this.pendingPingRequests.get(message.getMessageId());\n\n\tif (request != null && request.validateMessageResponse(message)) {\n\t\tthis.pendingPingRequests.remove(message.getMessageId());\n\t\tNodeChallenge challenge = this.challengeManager.removeChallenge(message.getMessageId());\n\t\tif (challenge == null) {\n\t\t\tthis.addConnection(message, ip, message.getPort());\n\t\t}\n\t}\n}\n...\nprivate void addConnection(PongPeerMessage message, String ip, int port) {\n\tNode senderNode = new Node(message.getNodeId().getID(), ip, port);\n\tif (!StringUtils.equals(senderNode.getHexId(), this.localNode.getHexId())) {\n\t\tOperationResult result = this.distanceTable.addNode(senderNode);\n\n\t\tif (result.isSuccess()) {\n\t\t\tNodeID senderId = senderNode.getId();\n\t\t\tthis.establishedConnections.put(senderId, senderNode);\n\t\t\tlogger.debug(\"New Peer found ip:[{}] port[{}]\", ip, port);\n\t\t} else {\n\t\t\tthis.challengeManager.startChallenge(result.getAffectedEntry().getNode(), senderNode, this);\n\t\t}\n\t}\n}\n```\nThe `addConnection` method first attempts to add N1 to the `NodeDistanceTable` - a structure designed to hold a limited number of nodes (by default, 4096). If this insertion fails due to the target `NodeDistanceTable` bucket already being full, the attempted connection is instead added to `NodeChallengeManager`. The relevant code snippets from `NodeChallengeManager.java` are below:\n```\npublic NodeChallenge startChallenge(Node challengedNode, Node challenger, PeerExplorer explorer) {\n\tPingPeerMessage pingMessage = explorer.sendPing(challengedNode.getAddress(), 1, challengedNode);\n\tString messageId = pingMessage.getMessageId();\n\tNodeChallenge challenge = new NodeChallenge(challengedNode, challenger, messageId);\n\tactiveChallenges.put(messageId, challenge);\n\treturn challenge;\n}\n\npublic NodeChallenge removeChallenge(String challengeId) {\n\treturn activeChallenges.remove(challengeId);\n}\n```\n\nThrough the `startChallenge` method N2 will send N1 another ping message, adding a \"challenge\" to `activeChallenges` with that new ping message's `messageId`. The issue here is that **the entry is only ever removed from `activeChallenges` if N1 replies with a pong that has the same `messageId` as the new ping message** - as seen in `PeerExplorer.handlePong`. Thus, N1 is able to create an arbitrary number of entries in `activeChallenges` by never sending N2 a pong with the challenge ping's `messageId`.\n\nIt should be noted that there is a slight limitation as to how this could be exploited by a single host. The relevant code snippets from `PeerExplorer.java` are below:\n```\npublic PingPeerMessage sendPing(InetSocketAddress nodeAddress, int attempt, Node node) {\n\tPingPeerMessage nodeMessage = checkPendingPeerToAddress(nodeAddress);\n\n\tif (nodeMessage != null) {\n\t\treturn nodeMessage;\n\t}\n\t....\n}\n...\nprivate PingPeerMessage checkPendingPeerToAddress(InetSocketAddress address) {\n\tfor (PeerDiscoveryRequest req : this.pendingPingRequests.values()) {\n\t\tif (req.getAddress().equals(address)) {\n\t\t\treturn (PingPeerMessage) req.getMessage();\n\t\t}\n\t}\n\n\treturn null;\n}\n\n```\nThe `sendPing` method will only ever actually send a new ping to N1 if there are no pending pings to its `InetSocketAddress` (which is deemed equal if the host and port match) - as seen in `checkPendingPeerToAddress`. However, pending pings have a set expiry time (by default, 30 seconds) and those that have expired are cleared by `PeerExplorerCleaner` at a fixed rate (by default, every 60 seconds). So due to this limitation, with the default configuration settings a single host can only complete 65,535 handshakes (one per port) every minute - imposing a (perhaps unreachable) limit on the time it takes to exhaust the target node's memory. Though this can obviously be circumvented by using multiple hosts to attack a target node. \n\n\nBecause most peer discovery functionality identifies nodes by their `NodeID` and not by host/port, it's trivial to send a flood of requests with unique `NodeID`s to fill `NodeDistanceTable` and subsequently make an unrestricted amount of in-memory insertions into `NodeChallengeManager.activeChallenges`. This is further aided by the fact that `NodeChallengeManager` is never purged, so the request flood does not have to occur within a short period of time. Memory exhaustion will eventually occur as the `NodeChallenge` objects begin taking up a significant amount of memory and are not eligible for garbage collection. This is expected to eventually disable node functionality as individual threads die when they throw `OutOfMemoryError`s, but in my testing it ended up crashing the whole JVM after reaching ~200,000 insertions.\n\n## Steps To Reproduce:\n\nI've attached a PoC program that interfaces with the RSKj library for the sake of simplicity. Due to the PoC program being somewhat inefficient and unreliable, I ended up accelerating the testing process by modifying my testing node's `NodeChallengeManager` to make 10 insertions per valid `startChallenge` call. If you're interested in running the PoC despite those issues, follow these steps:\n  1. Download a copy of the RSKj code\n  2. Move the PoC files into the `co.rsk.net.discovery` package (overwrite `PeerExplorer.java` with my modified version)\n  3. Launch a node for testing - ensure peer discovery is enabled\n  4. Compile and run the PoC from `PeerFlood` - arguments format: `<local_address> <target_address> <target_port> <num_threads>`\n  5. Monitor testing node's logs and stability\n\nIf you're developing your own PoC, you need to simply flood a testing node with connections that use random `NodeID`s, completing a single ping<->pong handshake then immediately disconnecting.\n\n## Mitigation\nThis could be mitigated by implementing expiring challenges that are cleared by `PeerExplorerCleaner`.\n\n## Impact\n\nAn attacker could crash any RSKj node with peer discovery enabled (which it is by default).",
  "bounty_amount": "4000.0",
  "formatted_bounty": "$4,000",
  "weakness": {
    "id": 48,
    "name": "Uncontrolled Resource Consumption"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [
    {
      "id": 306904,
      "file_name": "PoC.zip",
      "expiring_url": "https://hackerone-us-west-2-production-attachments.s3.us-west-2.amazonaws.com/000/306/904/b3bb57dc81076b13db555b631fa4d85b459d15bd/PoC.zip?response-content-disposition=attachment%3B%20filename%3D%22PoC.zip%22%3B%20filename%2A%3DUTF-8%27%27PoC.zip&response-content-type=application%2Fzip&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAQGK6FURQZ56IR27L%2F20250921%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250921T143938Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEI3%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQC2lMRFmWCHhr%2BJNECl1sGrPTozu0B4CqSvp1JYeOWk2wIgHw%2Fug30iKOYlnLieSD7VpW6F4NwXgU4T0n5ovzArnooqsQUIFhADGgwwMTM2MTkyNzQ4NDkiDP%2B9pvCpDtieepJDKSqOBax3xK1OGSOoPE8oe0TypxR5JdRZH80bP8p6qTxkjMdLG4TmpG94B1w70DAkUnocUI0cCciCUWKQ%2FRB9HnZsLClWO8OYSC6QLzfoEb8WcfAapWbumEz5q2ryMSqIDDnww%2F6Vw3SlcghwenfpyrzvXevVVxwU8W3XTYD4BvmYwvy3hQE%2B37uOncdpd4Q%2BR9lklPHry7mp7Ixi%2FK9j1fKl0QS7HJxDgppew5z4SvwUKDi7174ZG0T%2BTxal148HJfLWX%2BhkRjGLJINti7gFw5eQUMW6WF9jdcF8S4EZAcEZBoqJ8m9aZOk%2B9FyEb8SxGzy13lJmAsCeArUopzv0idL1OklAImbVRCP1kjM8J8jFd73gXH2l8QxTvDPv3pKTUSIYjmYt64MXXEiYUO3KE4TNVqvheCB252c0V4ybMU94u0D9Xo5MKHRbelJ5JauOmDNbncclw2uuh8eHMoY%2FDAPd0XKXcSfSw8LWYZ4nKM3LMVdv52%2BKK9N7dy4Y%2FCtCDdPSGau4mTczSSp9Lndj2Q%2BV9AELP4YseVg3RYdTkr2PMAWPPztBFCSPj1mn2YlRRvWr%2Fa%2FLsUAeXgk3BK5cown4gRLLCXsX7OfSAUC1P63Sm0kuIxR9gXo62kR79mVOPDCUIA8k9d%2BgYf8jQVAHyx%2FkqlCXtlWmruVxEMq%2FCAD7A8g1dQMfGIbkfhL1U9you6bgwDrkW7JryqyBW0qTinPQKn3F4uC1R%2FdJjdlKD%2FzAVrzk53FQBJOkzBB5uYz5QEf5fzX1KH6pQkWZZxuhTji9WUHt5AUVOxT5PuN72SZZU9NbUb%2F3EsjRmB%2BkuBMEEjvqLnrUSy%2BJx%2FD2AOvpZmTo4XuO8jGVuB3K6B123%2Fj0%2BDC64b%2FGBjqxAVVzGvBjg86Wgaiw5L%2BJWXtWyMpuvK4lXSUzZeh1Mdq%2FjUp0bD34CobaDfqUopt%2B43hiZUiUlv2pVrrU4N8w181naJ6Xysk2%2BA%2B%2F57W4TMMh1XzOPoQcsMkgS%2B26RLk7qetiNdR8f11wjD1t38c5RQSMd28QyFJJA5GzLKaa50WzF8%2F73dYchgyraDeMJW5UdfhRXErV%2FTZoMaAwUAgTlbr79kSNnYdejSAPOwqwDIqfjQ%3D%3D&X-Amz-SignedHeaders=host&X-Amz-Signature=25d4cd752d1879d44b64a670cd9fb6350c80c3f64794dcf11b4d102c0aaeac3d",
      "file_size": 2341,
      "type": "application/zip",
      "moderated": null
    }
  ],
  "allow_singular_disclosure_at": null,
  "vote_count": 49,
  "voters": [
    "n1m0",
    "ali",
    "sameerphad72",
    "tess",
    "lucash-dev",
    "spam404",
    "dhakal_ananda",
    "s_p_q_r",
    "theappsec",
    "foreguard",
    "and 39 more..."
  ],
  "severity": {
    "rating": "high",
    "score": 7.7,
    "author_type": "Team",
    "metrics": {
      "attack_vector": "network",
      "attack_complexity": "high",
      "privileges_required": "none",
      "user_interaction": "none",
      "scope": "unchanged",
      "confidentiality": "none",
      "integrity": "none",
      "availability": "high"
    }
  },
  "structured_scope": {
    "databaseId": 5820,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/rsksmart/rskj",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
