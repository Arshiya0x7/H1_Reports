{
  "id": 3493602,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8zNDkzNjAy",
  "url": "https://hackerone.com/reports/3493602",
  "title": "Stack Buffer Overflow in mprintf.c formatting function (fallback path)",
  "state": "Closed",
  "substate": "informative",
  "severity_rating": "high",
  "readable_substate": "Informative",
  "created_at": "2026-01-07T22:12:52.272Z",
  "submitted_at": "2026-01-07T22:12:52.714Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "is_triager?": false,
  "reporter": {
    "disabled": false,
    "username": "han_ank",
    "url": "/han_ank",
    "profile_picture_urls": {
      "small": "/assets/avatars/default-14ffa99f59cd01423c64904352cc130ffcb6a802eadfd11777a54485749e60f2.png"
    },
    "is_me?": false,
    "cleared": false,
    "verified": false,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 35663,
    "url": "https://hackerone.com/curl",
    "handle": "curl",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/000/035/663/2faf4c279d437d64bfda6d23d62ce1833813a4d9_original.png/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "curl",
      "twitter_handle": "",
      "website": "https://curl.se",
      "about": "cURL is an Open Source project providing a library and command-line tool doing internet transfers"
    }
  },
  "has_bounty?": false,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": true,
  "disclosed_at": "2026-01-08T09:36:29.608Z",
  "bug_reporter_agreed_on_going_public_at": "2026-01-08T09:36:29.409Z",
  "team_member_agreed_on_going_public_at": "2026-01-08T09:01:16.660Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "### Summary\nA stack-based buffer overflow exists in `mprintf.c` within the `out_double()` function. This vulnerability affects builds where `HAVE_SNPRINTF` is undefined, forcing the use of the legacy `sprintf` function.\n\nThe logic responsible for calculating the maximum safe precision (`maxprec`) for floating-point formatting fails to correctly handle negative numbers. Specifically, it does not properly account for the number of digits required by the integer portion of negative values. As a result, the buffer size calculation is incorrect, allowing a subsequent `sprintf` call to write more data than the fixed-size stack buffer can hold.\n\n\n### Affected Component\n- **File:** `lib/mprintf.c`\n- **Function:** `out_double()`\n- **Vulnerable Condition:** `HAVE_SNPRINTF` is not defined at compile time\n\n\n### Technical Details\nThe function uses a local stack buffer (`work`) of size `BUFFSIZE` (326 bytes). To prevent overflow, the code attempts to estimate the number of digits required for the integer part of the floating-point value and reduce the allowable precision accordingly.\n\nThe relevant code is shown below (approx. line 675 in `master`):\n\n```c\nwhile(val >= 10.0) {\n  val /= 10;\n  maxprec--;\n}\n````\n\nFor negative values (e.g., `-1.0e100`), the condition `val >= 10.0` is false on entry, so the loop is skipped entirely. As a result, `maxprec` is not reduced, even though the integer portion of the formatted value will consume significant buffer space. The subsequent `sprintf` call writes the minus sign, the full integer portion, and the requested fractional precision, exceeding the 326-byte stack buffer.\n\n\n## Steps To Reproduce\n\n1. **Configure the Build**\n\n   Compile `libcurl` with `HAVE_SNPRINTF` undefined to force the fallback `sprintf` path. One way to simulate this is by modifying `lib/mprintf.c`:\n\n   ```c\n   #if 0 /* Force fallback path for testing */\n     (snprintf)(work, BUFFSIZE, formatbuf, dnum);\n   #else\n     (sprintf)(work, formatbuf, dnum); /* Vulnerable path */\n   #endif\n   ```\n\n2. **Compile Reproduction Program**\n\n   Compile the following C program against the modified `libcurl` build:\n\n   ```c\n   #include <stdio.h>\n   #include <curl/curl.h>\n   #include <string.h>\n\n   int main(void) {\n       // -1.0e100 requires ~102 characters for the integer part\n       // Precision .300 requires 300 characters for the fractional part\n       // Total output length ~402 characters\n       // Stack buffer size in mprintf.c is 326 bytes\n       double v = -1.0e100;\n\n       char *output = curl_maprintf(\"%.300f\", v);\n       \n       if (output) {\n           printf(\"Output length: %lu bytes\\n\",\n                  (unsigned long)strlen(output));\n           curl_free(output);\n       }\n       return 0;\n   }\n   ```\n\n3. **Run the Program**\n\n4. **Observe**\n\n   The output length exceeds the 326-byte buffer size. Depending on stack protections (stack canaries, ASLR), this results in a segmentation fault or stack smashing detection.\n\n\n## Suggested Fix\n\nCorrect the integer digit calculation to account for negative values by operating on the absolute value (or equivalent logic):\n\n```c\ndouble absval = fabs(val);\n\nwhile(absval >= 10.0) {\n  absval /= 10.0;\n  maxprec--;\n}\n```\n\nOptionally, clamp `maxprec` to prevent underflow:\n\n```c\nif(maxprec < 0)\n  maxprec = 0;\n```\n\n## Impact\n\nThis vulnerability results in a classic stack-based buffer overflow.\n\n* **Availability:** Denial of Service (application crash)\n* **Security Impact:** In scenarios where the floating-point value and format string are influenced by attacker-controlled input, this issue could potentially be leveraged for further memory corruption, including control-flow manipulation.\n* **Scope:** The vulnerable code path is part of the legacy fallback implementation and is not used in default modern curl builds. It primarily affects legacy Unix systems, embedded platforms, or custom builds where `snprintf` is unavailable or explicitly disabled.",
  "weakness": {
    "id": 3,
    "name": "Classic Buffer Overflow"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": null,
  "vote_count": 1,
  "voters": [
    "2026"
  ],
  "severity": {
    "rating": "high",
    "author_type": "User"
  },
  "structured_scope": {
    "databaseId": 18844,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/curl/curl",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
