{
  "id": 2779070,
  "global_id": "Z2lkOi8vaGFja2Vyb25lL1JlcG9ydC8yNzc5MDcw",
  "url": "https://hackerone.com/reports/2779070",
  "title": "Memory Leak in bytes_to_hexstring Function",
  "state": "Closed",
  "substate": "resolved",
  "severity_rating": "low",
  "readable_substate": "Resolved",
  "created_at": "2024-10-13T06:42:20.240Z",
  "submitted_at": "2024-10-13T06:42:20.555Z",
  "is_member_of_team?": false,
  "is_organization_group_member?": false,
  "reporter": {
    "disabled": false,
    "username": "kinkajouuuu",
    "url": "/kinkajouuuu",
    "profile_picture_urls": {
      "small": "https://hackerone.com/rails/active_storage/representations/redirect/eyJfcmFpbHMiOnsiZGF0YSI6NzQyMDc1MiwicHVyIjoiYmxvYl9pZCJ9fQ==--d3a10b52a3ed23b452e0c4b8fa70042b0af3b487/eyJfcmFpbHMiOnsiZGF0YSI6eyJmb3JtYXQiOiJqcGVnIiwiZ3Jhdml0eSI6IkNlbnRlciIsInJlc2l6ZSI6IjYyeDYyXiIsImNyb3AiOiI2Mng2MiswKzAifSwicHVyIjoidmFyaWF0aW9uIn19--0e8fb5b1a245559716caa2abf00b1571bf3c5040/IMG_5317.jpeg"
    },
    "is_me?": false,
    "cleared": false,
    "verified": true,
    "hackerone_triager": false,
    "hacker_mediation": false
  },
  "team": {
    "id": 22522,
    "url": "https://hackerone.com/hyperledger",
    "handle": "hyperledger",
    "profile_picture_urls": {
      "small": "https://profile-photos.hackerone-user-content.com/variants/4unr4nty3m2omunib0bwxy2s189l/235acf2ba808c3a51a94888fb977392c26f8fb0ccf77a81a4546c5e4065c06f1",
      "medium": "https://profile-photos.hackerone-user-content.com/variants/4unr4nty3m2omunib0bwxy2s189l/3f1ab5c6a9b6dadada1e6c8121700b884388bd0a43471fee1897a38ce57d0b2c"
    },
    "permissions": [],
    "submission_state": "open",
    "default_currency": "usd",
    "awards_miles": false,
    "offers_bounties": true,
    "state": "public_mode",
    "only_cleared_hackers": false,
    "pentest_feature_enabled?": false,
    "pentest_retesting_ends_at": null,
    "profile": {
      "name": "Linux Foundation Decentralized Trust",
      "twitter_handle": "lfdecentralized",
      "website": "https://www.lfdecentralizedtrust.org/",
      "about": "An industry-wide open source initiative to advance blockchain technology, governed by The Linux Foundation."
    }
  },
  "has_bounty?": true,
  "can_view_team": true,
  "can_view_report": true,
  "is_external_bug": false,
  "is_published": false,
  "is_participant": false,
  "has_collaborators": false,
  "submitted_by_team_member": false,
  "submitted_with_assistant": false,
  "stage": 4,
  "public": true,
  "visibility": "full",
  "cve_ids": [],
  "singular_disclosure_disabled": false,
  "disclosed_at": "2024-10-24T16:15:11.266Z",
  "bug_reporter_agreed_on_going_public_at": "2024-10-24T15:47:10.311Z",
  "team_member_agreed_on_going_public_at": "2024-10-24T16:15:10.889Z",
  "comments_closed?": false,
  "facebook_team?": false,
  "team_private?": false,
  "vulnerability_information": "## Overview\nThe function` bytes_to_hexstring` located in the `utils.c` file has a confirmed memory leak vulnerability. This function is responsible for converting an array of bytes into a hexadecimal string representation. However, it allocates memory dynamically using `malloc` without any error handling or memory management practices to ensure that the allocated memory is freed after use. This can result in a memory leak, which occurs when dynamically allocated memory is not properly released, leading to potential resource exhaustion over time.\n\n## Vulnerability Details\n\n- **Function:** [`bytes_to_hexstring`](https://github.com/hyperledger/fabric-private-chaincode/blob/2b8ae267b37f0680a4a012f91058bcf78cdf2f79/common/utils.c#L33)\n\n```c\nchar* bytes_to_hexstring(uint8_t* bytes, size_t len)\n{\n    const char* hexdigs = \"0123456789abcdef\";\n    size_t k = len * 2 + 1;\n    char* out = malloc(k);\n    for (int i = 0; i < len; i++)\n    {\n        out[i * 2] = hexdigs[bytes[i] >> 4];\n        out[i * 2 + 1] = hexdigs[bytes[i] & 0x0f];\n    }\n    out[k - 1] = '\\0';\n    return out;\n}\n```\n\n## Description of the Vulnerability:\n\n- The function `bytes_to_hexstring` allocates memory using `malloc(k)` to hold the hexadecimal string (`k = len * 2 + 1`, where len is the length of the input byte array).\n\n- After this memory allocation, the function proceeds to fill the buffer with hexadecimal characters but **never frees the memory** before the function exits.\n\n- This memory must be freed after the function is called, but **the function does not document or enforce the requirement for the caller to free the memory**.\n\n- If the caller fails to release the allocated memory, it will lead to a **memory leak**, as the system cannot reclaim the dynamically allocated memory until the program terminates.\n\n## Steps to Reproduce the Vulnerability\n\n**1)** Call the `bytes_to_hexstring` function multiple times in a loop without freeing the memory it returns.\n\n***Example:**\n\n```c\nfor (int i = 0; i < 10000; i++) {\n    uint8_t data[10] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09};\n    char* hex_str = bytes_to_hexstring(data, 10);\n    // Do something with hex_str but forget to free it\n}\n```\n\n**2)** Observe the program's increasing memory consumption, which can be monitored using system tools like `top` (Linux), `Task Manager` (Windows), or similar.\n\n**3)** Eventually, the program will either crash or severely degrade the performance of the system due to high memory usage.\n\n## Suggested Mitigations\n\n**1) Free Allocated Memory:** Ensure that the caller of the function is responsible for freeing the dynamically allocated memory.\n\n   - The function should document that it returns a pointer to allocated memory, and it is the responsibility of the caller to free() that memory once it is no longer needed.\nExample of proper usage:\n\n```c\nchar* hex_str = bytes_to_hexstring(data, len);\n// Use hex_str...\nfree(hex_str); // Ensure that the allocated memory is freed\n```\n\n**2) Error Handling for Memory Allocation:** Check the return value of `malloc` for `NULL`. This would add resilience in case of memory allocation failure.\n\n   - Updated code with error handling:\n\n```c\nchar* bytes_to_hexstring(uint8_t* bytes, size_t len)\n{\n    const char* hexdigs = \"0123456789abcdef\";\n    size_t k = len * 2 + 1;\n    char* out = malloc(k);\n    if (out == NULL) {\n        return NULL; // Return NULL if memory allocation fails\n    }\n    for (int i = 0; i < len; i++) {\n        out[i * 2] = hexdigs[bytes[i] >> 4];\n        out[i * 2 + 1] = hexdigs[bytes[i] & 0x0f];\n    }\n    out[k - 1] = '\\0';\n    return out;\n}\n```\n\n**3) Considerations for Caller Responsibility:** If possible, implement a more robust memory management strategy where the allocation and deallocation of memory are managed by the same function or encapsulated in a higher-level API. For instance, passing in an already-allocated buffer to be filled instead of returning a dynamically allocated buffer.\n\n## Impact\n\n## Implications of the Memory Leak:\n- **Resource Exhaustion:** Over time, if `bytes_to_hexstring` is called repeatedly in a long-running program without freeing the returned memory, the program's memory consumption will increase. This can lead to performance degradation, or in worse cases, system crashes due to memory exhaustion.\n\n- **Denial of Service (DoS):** A malicious user could exploit this vulnerability by triggering multiple invocations of this function, exhausting available memory resources and leading to denial of service.\n\n## Conclusion\nThis report highlights a confirmed **memory leak** vulnerability in the `bytes_to_hexstring` function. The lack of proper memory management results in an increasing consumption of system resources, potentially leading to system crashes or denial of service (DoS) attacks.\n\nThe solution involves proper memory deallocation, ensuring that the caller frees the returned memory, and adding error handling for memory allocation failures. Addressing these issues will significantly improve the stability and security of the application.\n\n**Severity Rating:**\n\n- **Impact:** Medium\n- **Likelihood:** High (if the function is used in long-running applications)\n**Recommended Fix Priority:** High\n\n- References:\n\nCommon Weakness Enumeration (CWE-401): Memory Leak",
  "weakness": {
    "id": 50,
    "name": "Use After Free"
  },
  "original_report_id": null,
  "original_report_url": null,
  "attachments": [],
  "allow_singular_disclosure_at": "2024-11-23T15:47:10.563Z",
  "allow_singular_disclosure_after": -26014333.48953643,
  "singular_disclosure_allowed": true,
  "vote_count": 25,
  "voters": [
    "roland_hack",
    "zy9ard3",
    "goedix",
    "thalaivar304",
    "spaghettisec",
    "kinkajouuuu",
    "drhackapunk",
    "radosma",
    "jovem",
    "al-theeb",
    "and 15 more..."
  ],
  "severity": {
    "rating": "low",
    "author_type": "Team"
  },
  "structured_scope": {
    "databaseId": 179166,
    "asset_type": "SOURCE_CODE",
    "asset_identifier": "https://github.com/hyperledger/fabric-private-chaincode",
    "max_severity": "critical"
  },
  "abilities": {
    "assignable_team_members": [],
    "assignable_team_member_groups": []
  },
  "summaries": [
    {
      "category": "team",
      "can_view?": true,
      "can_create?": false
    },
    {
      "category": "researcher",
      "can_view?": true,
      "can_create?": false
    }
  ]
}
